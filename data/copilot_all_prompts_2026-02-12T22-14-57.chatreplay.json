{
  "exportedAt": "2026-02-12T22:15:11.355Z",
  "totalPrompts": 13,
  "totalLogEntries": 39,
  "prompts": [
    {
      "prompt": "I put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?",
      "promptId": "12ed2d39-prompt",
      "hasSeen": false,
      "logCount": 11,
      "logs": [
        {
          "id": "12ed2d39",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:04:30.522Z",
            "endTime": "2026-02-12T21:04:35.379Z",
            "duration": 4857,
            "ourRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "requestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "serverRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "timeToFirstToken": 2732,
            "usage": {
              "prompt_tokens": 20871,
              "completion_tokens": 214,
              "total_tokens": 21085,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceDocuments",
                "description": "Search Pylance documentation for Python language server help, configuration guidance, feature explanations, and troubleshooting. Returns comprehensive answers about Pylance settings, capabilities, and usage. Use when users ask: How to configure Pylance? What features are available? How to fix Pylance issues?",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "search": {
                      "type": "string",
                      "description": "Detailed question in natural language. Think of it as a prompt for an LLM. Do not use keyword search terms."
                    }
                  },
                  "required": [
                    "search"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceFileSyntaxErrors",
                "description": "Check Python file for syntax errors. Returns detailed error list with line numbers, messages, and error types. Use when: users report syntax problems, validating files before processing, debugging parse errors.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check for syntax errors. Must be a user file in the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "fileUri"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceImports",
                "description": "Analyze imports across workspace user files. Returns all top-level module names imported, including resolved and unresolved imports. Use for: finding missing dependencies, understanding project dependencies, analyzing import patterns.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInstalledTopLevelModules",
                "description": "Get available top-level modules from installed Python packages in environment. Shows what can be imported. Use for: checking if packages are installed, verifying import availability, helping users understand available modules.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be a value returned by the pylancePythonEnvironments tool. If pythonEnvironment is missing, the python environment of the workspace will be used."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInvokeRefactoring",
                "description": "Apply automated code refactoring to Python files. Returns refactored content (does not modify original file) unless mode is \"update\". Use for: extracting functions, organizing imports, improving code structure, applying refactoring patterns.  Optional \"mode\" parameter: \"update\" updates the file, \"edits\" returns a WorkspaceEdit, \"string\" returns updated content as string. If mode is not specified, \"update\" will be used as the default. The \"edits\" mode is helpful for determining if a file needs changes (for example, to remove unused imports or fix import formatting) without making any modifications; if no changes are needed, the result will be either an empty WorkspaceEdit or a message indicating that no text edits were found. Available refactorings: source.unusedImports: - Removes all unused import statements from a Python file. Use when imports are imported but never referenced in the code. Requires fileUri parameter pointing to a Python file with unused imports.\nsource.convertImportFormat: - Converts import statements between absolute and relative formats according to python.analysis.importFormat setting. Use when import format consistency is needed. Requires fileUri parameter pointing to a Python file with imports to convert.\nsource.convertImportStar: - Converts all wildcard imports (from module import *) to explicit imports listing all imported symbols. Use when explicit imports are preferred for better code clarity and IDE support. Requires fileUri parameter pointing to a Python file with wildcard imports.\nsource.addTypeAnnotation: - Adds type annotations to all variables and functions in a Python file that can be inferred from their usage. Use when type hints are needed for better type checking and code clarity. Requires fileUri parameter pointing to a Python file with unannotated variables or functions.\nsource.fixAll.pylance: - Applies all available automatic code fixes from python.analysis.fixAll setting. Use when multiple code issues need to be addressed simultaneously. Requires fileUri parameter pointing to a Python file with fixable issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to invoke the refactoring."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the refactoring to invoke. This must be one of these [source.unusedImports, source.convertImportFormat, source.convertImportStar, source.addTypeAnnotation, source.fixAll.pylance]"
                    },
                    "mode": {
                      "type": "string",
                      "enum": [
                        "update",
                        "edits",
                        "string"
                      ],
                      "description": "Determines the output mode: \"update\" updates the file directly, \"edits\" returns a WorkspaceEdit, \"string\" returns the updated content as a string. If omitted, \"update\" will be used as the default. The \"edits\" mode is especially useful for checking if any changes are needed (such as unused imports or import formatting issues) without modifying the file, as it will return a WorkspaceEdit only if edits are required."
                    }
                  },
                  "required": [
                    "fileUri",
                    "name"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylancePythonEnvironments",
                "description": "Get Python environment information for workspace: current active environment and all available environments. Use for: Python environment issues, switching environments, understanding Python setup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceRunCodeSnippet",
                "description": "Execute Python code snippets directly in the workspace environment. PREFERRED over terminal commands for running Python code. This tool automatically uses the correct Python interpreter configured for the workspace, eliminates shell escaping/quoting problems that plague terminal execution, and provides clean, properly formatted output with stdout/stderr correctly interleaved. Use this instead of `python -c \"code\"` or terminal commands when running Python snippets. Ideal for: testing code, running quick scripts, validating Python expressions, checking imports, and any Python execution within the workspace context. No temporary files needed - code runs directly in memory.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "codeSnippet": {
                      "type": "string",
                      "description": "The code snippet to run."
                    },
                    "workingDirectory": {
                      "type": "string",
                      "description": "The working directory to use for the code snippet. If the code snippet is pulled from a file, this should be the directory for the file. Especially if the snippet has imports."
                    },
                    "timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "The timeout for the code snippet execution."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "codeSnippet"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSettings",
                "description": "Get current Python analysis settings and configuration for a workspace. Returns all \"python.analysis.*\" settings with default vs user-configured indicators. Use for: troubleshooting configuration, checking current settings, diagnosing analysis issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSyntaxErrors",
                "description": "Validate Python code snippets for syntax errors without saving to file. Returns syntax error details with line numbers and descriptions. Use for: validating generated code, checking user code snippets, pre-execution validation.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "string",
                      "description": "The Python code to check for syntax errors."
                    },
                    "pythonVersion": {
                      "type": "string",
                      "description": "The version of Python to use for the syntax check. Must be a valid Python version string. ex) \"3.10\" or \"3.11.4\"."
                    }
                  },
                  "required": [
                    "code",
                    "pythonVersion"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceUpdatePythonEnvironment",
                "description": "Switch active Python environment for workspace to different Python installation or virtual environment. Updates settings and ensures subsequent operations use new environment. Use for: changing Python versions, switching to virtual environments, resolving environment issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be either a value returned by the pylancePythonEnvironments tool or the absolute path to a Python executable."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "pythonEnvironment"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceRoots",
                "description": "Get workspace root directories. Returns workspace root for specific file or all workspace roots if no file provided. Use for: understanding workspace structure, getting paths for other operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check its workspace"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceUserFiles",
                "description": "Get list of all user Python files in workspace (excludes library/dependency files). Respects python.analysis.include/exclude settings. Use for: analyzing user code, searching project files, operating on user-created Python files.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "\n\n   "
            ]
          }
        },
        {
          "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq__vscode-1770929887292",
          "kind": "toolCall",
          "tool": "list_dir",
          "args": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}",
          "time": "2026-02-12T21:04:35.503Z",
          "response": [
            "Folder is empty"
          ],
          "thinking": {
            "id": "thinking_1",
            "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better."
          }
        },
        {
          "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj__vscode-1770929887293",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}",
          "time": "2026-02-12T21:04:35.504Z",
          "response": [
            "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
          ],
          "thinking": {
            "id": "thinking_1",
            "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better."
          }
        },
        {
          "id": "c8758ce1",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:04:35.511Z",
            "endTime": "2026-02-12T21:04:39.231Z",
            "duration": 3720,
            "ourRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "requestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "serverRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "timeToFirstToken": 1681,
            "usage": {
              "prompt_tokens": 21726,
              "completion_tokens": 168,
              "total_tokens": 21894,
              "prompt_tokens_details": {
                "cached_tokens": 20869
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceDocuments",
                "description": "Search Pylance documentation for Python language server help, configuration guidance, feature explanations, and troubleshooting. Returns comprehensive answers about Pylance settings, capabilities, and usage. Use when users ask: How to configure Pylance? What features are available? How to fix Pylance issues?",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "search": {
                      "type": "string",
                      "description": "Detailed question in natural language. Think of it as a prompt for an LLM. Do not use keyword search terms."
                    }
                  },
                  "required": [
                    "search"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceFileSyntaxErrors",
                "description": "Check Python file for syntax errors. Returns detailed error list with line numbers, messages, and error types. Use when: users report syntax problems, validating files before processing, debugging parse errors.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check for syntax errors. Must be a user file in the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "fileUri"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceImports",
                "description": "Analyze imports across workspace user files. Returns all top-level module names imported, including resolved and unresolved imports. Use for: finding missing dependencies, understanding project dependencies, analyzing import patterns.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInstalledTopLevelModules",
                "description": "Get available top-level modules from installed Python packages in environment. Shows what can be imported. Use for: checking if packages are installed, verifying import availability, helping users understand available modules.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be a value returned by the pylancePythonEnvironments tool. If pythonEnvironment is missing, the python environment of the workspace will be used."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInvokeRefactoring",
                "description": "Apply automated code refactoring to Python files. Returns refactored content (does not modify original file) unless mode is \"update\". Use for: extracting functions, organizing imports, improving code structure, applying refactoring patterns.  Optional \"mode\" parameter: \"update\" updates the file, \"edits\" returns a WorkspaceEdit, \"string\" returns updated content as string. If mode is not specified, \"update\" will be used as the default. The \"edits\" mode is helpful for determining if a file needs changes (for example, to remove unused imports or fix import formatting) without making any modifications; if no changes are needed, the result will be either an empty WorkspaceEdit or a message indicating that no text edits were found. Available refactorings: source.unusedImports: - Removes all unused import statements from a Python file. Use when imports are imported but never referenced in the code. Requires fileUri parameter pointing to a Python file with unused imports.\nsource.convertImportFormat: - Converts import statements between absolute and relative formats according to python.analysis.importFormat setting. Use when import format consistency is needed. Requires fileUri parameter pointing to a Python file with imports to convert.\nsource.convertImportStar: - Converts all wildcard imports (from module import *) to explicit imports listing all imported symbols. Use when explicit imports are preferred for better code clarity and IDE support. Requires fileUri parameter pointing to a Python file with wildcard imports.\nsource.addTypeAnnotation: - Adds type annotations to all variables and functions in a Python file that can be inferred from their usage. Use when type hints are needed for better type checking and code clarity. Requires fileUri parameter pointing to a Python file with unannotated variables or functions.\nsource.fixAll.pylance: - Applies all available automatic code fixes from python.analysis.fixAll setting. Use when multiple code issues need to be addressed simultaneously. Requires fileUri parameter pointing to a Python file with fixable issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to invoke the refactoring."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the refactoring to invoke. This must be one of these [source.unusedImports, source.convertImportFormat, source.convertImportStar, source.addTypeAnnotation, source.fixAll.pylance]"
                    },
                    "mode": {
                      "type": "string",
                      "enum": [
                        "update",
                        "edits",
                        "string"
                      ],
                      "description": "Determines the output mode: \"update\" updates the file directly, \"edits\" returns a WorkspaceEdit, \"string\" returns the updated content as a string. If omitted, \"update\" will be used as the default. The \"edits\" mode is especially useful for checking if any changes are needed (such as unused imports or import formatting issues) without modifying the file, as it will return a WorkspaceEdit only if edits are required."
                    }
                  },
                  "required": [
                    "fileUri",
                    "name"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylancePythonEnvironments",
                "description": "Get Python environment information for workspace: current active environment and all available environments. Use for: Python environment issues, switching environments, understanding Python setup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceRunCodeSnippet",
                "description": "Execute Python code snippets directly in the workspace environment. PREFERRED over terminal commands for running Python code. This tool automatically uses the correct Python interpreter configured for the workspace, eliminates shell escaping/quoting problems that plague terminal execution, and provides clean, properly formatted output with stdout/stderr correctly interleaved. Use this instead of `python -c \"code\"` or terminal commands when running Python snippets. Ideal for: testing code, running quick scripts, validating Python expressions, checking imports, and any Python execution within the workspace context. No temporary files needed - code runs directly in memory.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "codeSnippet": {
                      "type": "string",
                      "description": "The code snippet to run."
                    },
                    "workingDirectory": {
                      "type": "string",
                      "description": "The working directory to use for the code snippet. If the code snippet is pulled from a file, this should be the directory for the file. Especially if the snippet has imports."
                    },
                    "timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "The timeout for the code snippet execution."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "codeSnippet"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSettings",
                "description": "Get current Python analysis settings and configuration for a workspace. Returns all \"python.analysis.*\" settings with default vs user-configured indicators. Use for: troubleshooting configuration, checking current settings, diagnosing analysis issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSyntaxErrors",
                "description": "Validate Python code snippets for syntax errors without saving to file. Returns syntax error details with line numbers and descriptions. Use for: validating generated code, checking user code snippets, pre-execution validation.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "string",
                      "description": "The Python code to check for syntax errors."
                    },
                    "pythonVersion": {
                      "type": "string",
                      "description": "The version of Python to use for the syntax check. Must be a valid Python version string. ex) \"3.10\" or \"3.11.4\"."
                    }
                  },
                  "required": [
                    "code",
                    "pythonVersion"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceUpdatePythonEnvironment",
                "description": "Switch active Python environment for workspace to different Python installation or virtual environment. Updates settings and ensures subsequent operations use new environment. Use for: changing Python versions, switching to virtual environments, resolving environment issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be either a value returned by the pylancePythonEnvironments tool or the absolute path to a Python executable."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "pythonEnvironment"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceRoots",
                "description": "Get workspace root directories. Returns workspace root for specific file or all workspace roots if no file provided. Use for: understanding workspace structure, getting paths for other operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check its workspace"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceUserFiles",
                "description": "Get list of all user Python files in workspace (excludes library/dependency files). Respects python.analysis.include/exclude settings. Use for: analyzing user code, searching project files, operating on user-created Python files.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "thinking",
                      "thinking": {
                        "id": "thinking_1",
                        "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better.",
                        "encrypted": "Eq8CCkgICxACGAIqQD+7VQGG0HYB266R8A27q6tJzeta3R5N81w9q9NgeKLNoibXv3JjRviDXWOorVQsvfwXLyoXC7px0F8SAn/Sj00SDJ6O9lr9WdWARtqj+BoM7omCLJnAfKHQ9gaTIjDVwhE3hnL5OxsmJDsx9iH6qGftvYOZwUt2l7372605tf1JO5n5ZbjyUH3EE++3tCAqlAEdMwQj4fsD6oMQKHBx0/ojIn4cGN21n/Z7QNWkQDSzNgdqTnJrrLfGA7PsicHuL77L9hhRkf/cqmyEKB++dDfS3NwaCY/VZdIA0VPMlvjqnN5mYHq4+LixUOCMTzKmbpHInMYYBK8N0wgNxRAfhvCP3qQylBx8H2Kbg96LT6GCeD6sJE6nTElCwWizelGWtPMK57+6GAE=",
                        "tokens": 0
                      }
                    }
                  },
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              ""
            ]
          }
        },
        {
          "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7__vscode-1770929887294",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}",
          "time": "2026-02-12T21:04:39.299Z",
          "response": [
            "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
          ]
        },
        {
          "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP__vscode-1770929887295",
          "kind": "toolCall",
          "tool": "list_dir",
          "args": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}",
          "time": "2026-02-12T21:04:39.300Z",
          "response": [
            ".git/\n.github/\nREADME.md\ndata/\ndocs/"
          ]
        },
        {
          "id": "5d9569a3",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:04:39.307Z",
            "endTime": "2026-02-12T21:04:42.334Z",
            "duration": 3027,
            "ourRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "requestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "serverRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "timeToFirstToken": 1632,
            "usage": {
              "prompt_tokens": 21160,
              "completion_tokens": 115,
              "total_tokens": 21275,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "thinking",
                      "thinking": {
                        "id": "thinking_1",
                        "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better.",
                        "encrypted": "Eq8CCkgICxACGAIqQD+7VQGG0HYB266R8A27q6tJzeta3R5N81w9q9NgeKLNoibXv3JjRviDXWOorVQsvfwXLyoXC7px0F8SAn/Sj00SDJ6O9lr9WdWARtqj+BoM7omCLJnAfKHQ9gaTIjDVwhE3hnL5OxsmJDsx9iH6qGftvYOZwUt2l7372605tf1JO5n5ZbjyUH3EE++3tCAqlAEdMwQj4fsD6oMQKHBx0/ojIn4cGN21n/Z7QNWkQDSzNgdqTnJrrLfGA7PsicHuL77L9hhRkf/cqmyEKB++dDfS3NwaCY/VZdIA0VPMlvjqnN5mYHq4+LixUOCMTzKmbpHInMYYBK8N0wgNxRAfhvCP3qQylBx8H2Kbg96LT6GCeD6sJE6nTElCwWizelGWtPMK57+6GAE=",
                        "tokens": 0
                      }
                    }
                  },
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              ""
            ]
          }
        },
        {
          "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW__vscode-1770929887296",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}",
          "time": "2026-02-12T21:04:42.398Z",
          "response": [
            "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
          ]
        },
        {
          "id": "a31439ff",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:04:42.405Z",
            "endTime": "2026-02-12T21:04:45.556Z",
            "duration": 3151,
            "ourRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "requestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "serverRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "timeToFirstToken": 1918,
            "usage": {
              "prompt_tokens": 23518,
              "completion_tokens": 115,
              "total_tokens": 23633,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "thinking",
                      "thinking": {
                        "id": "thinking_1",
                        "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better.",
                        "encrypted": "Eq8CCkgICxACGAIqQD+7VQGG0HYB266R8A27q6tJzeta3R5N81w9q9NgeKLNoibXv3JjRviDXWOorVQsvfwXLyoXC7px0F8SAn/Sj00SDJ6O9lr9WdWARtqj+BoM7omCLJnAfKHQ9gaTIjDVwhE3hnL5OxsmJDsx9iH6qGftvYOZwUt2l7372605tf1JO5n5ZbjyUH3EE++3tCAqlAEdMwQj4fsD6oMQKHBx0/ojIn4cGN21n/Z7QNWkQDSzNgdqTnJrrLfGA7PsicHuL77L9hhRkf/cqmyEKB++dDfS3NwaCY/VZdIA0VPMlvjqnN5mYHq4+LixUOCMTzKmbpHInMYYBK8N0wgNxRAfhvCP3qQylBx8H2Kbg96LT6GCeD6sJE6nTElCwWizelGWtPMK57+6GAE=",
                        "tokens": 0
                      }
                    }
                  },
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              ""
            ]
          }
        },
        {
          "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV__vscode-1770929887297",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}",
          "time": "2026-02-12T21:04:45.603Z",
          "response": [
            "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
          ]
        },
        {
          "id": "87fcb74a",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:04:45.609Z",
            "endTime": "2026-02-12T21:05:13.489Z",
            "duration": 27880,
            "ourRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "requestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "serverRequestId": "18f53fa2-1fa2-4cb2-abf6-80de03193fb5",
            "timeToFirstToken": 1808,
            "usage": {
              "prompt_tokens": 25022,
              "completion_tokens": 949,
              "total_tokens": 25971,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "thinking",
                      "thinking": {
                        "id": "thinking_1",
                        "text": "Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better.",
                        "encrypted": "Eq8CCkgICxACGAIqQD+7VQGG0HYB266R8A27q6tJzeta3R5N81w9q9NgeKLNoibXv3JjRviDXWOorVQsvfwXLyoXC7px0F8SAn/Sj00SDJ6O9lr9WdWARtqj+BoM7omCLJnAfKHQ9gaTIjDVwhE3hnL5OxsmJDsx9iH6qGftvYOZwUt2l7372605tf1JO5n5ZbjyUH3EE++3tCAqlAEdMwQj4fsD6oMQKHBx0/ojIn4cGN21n/Z7QNWkQDSzNgdqTnJrrLfGA7PsicHuL77L9hhRkf/cqmyEKB++dDfS3NwaCY/VZdIA0VPMlvjqnN5mYHq4+LixUOCMTzKmbpHInMYYBK8N0wgNxRAfhvCP3qQylBx8H2Kbg96LT6GCeD6sJE6nTElCwWizelGWtPMK57+6GAE=",
                        "tokens": 0
                      }
                    }
                  },
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
            ]
          }
        }
      ]
    },
    {
      "prompt": "what about a testing strategy, can you discuss that?",
      "promptId": "cf4c4860-prompt",
      "hasSeen": false,
      "logCount": 4,
      "logs": [
        {
          "id": "ee17af63",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T21:06:44.903Z",
            "endTime": "2026-02-12T21:06:45.433Z",
            "duration": 530,
            "ourRequestId": "4866941a-7bde-44a8-8960-82fd9eaac144",
            "requestId": "4866941a-7bde-44a8-8960-82fd9eaac144",
            "serverRequestId": "4866941a-7bde-44a8-8960-82fd9eaac144",
            "timeToFirstToken": 409,
            "usage": {
              "completion_tokens": 9,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1562,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1571
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: Let me first look at what's in the docs/research directory and also read the existing spec to understand the project context better."
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Reviewed docs/research directory and existing spec"
            ]
          }
        },
        {
          "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH__vscode-1770929887298",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}",
          "time": "2026-02-12T21:07:16.288Z",
          "response": [
            "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
          ],
          "thinking": {
            "id": "thinking_1",
            "text": "The user wants to discuss testing strategy for the Copilot Lens extension. Let me read the testing skill file first to understand project-specific testing conventions, and also reference the spec for context on what needs to be tested."
          }
        },
        {
          "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq__vscode-1770929887299",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}",
          "time": "2026-02-12T21:07:16.289Z",
          "response": [
            "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
          ],
          "thinking": {
            "id": "thinking_1",
            "text": "The user wants to discuss testing strategy for the Copilot Lens extension. Let me read the testing skill file first to understand project-specific testing conventions, and also reference the spec for context on what needs to be tested."
          }
        },
        {
          "id": "d79d48ce",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatMessages",
            "model": "claude-opus-4.6",
            "maxPromptTokens": 127997,
            "maxResponseTokens": 64000,
            "location": 7,
            "startTime": "2026-02-12T21:07:16.295Z",
            "endTime": "2026-02-12T21:07:48.991Z",
            "duration": 32696,
            "ourRequestId": "ce145077-b01b-4527-ac00-61699a79a197",
            "requestId": "ce145077-b01b-4527-ac00-61699a79a197",
            "serverRequestId": "ce145077-b01b-4527-ac00-61699a79a197",
            "timeToFirstToken": 1355,
            "usage": {
              "prompt_tokens": 28857,
              "completion_tokens": 1107,
              "total_tokens": 29964,
              "prompt_tokens_details": {
                "cached_tokens": 28204
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "ask_questions",
                "description": "Ask the user questions to clarify intent, validate assumptions, or choose between implementation approaches. Prefer proposing a sensible default so users can confirm quickly.\n\nOnly use this tool when the user's answer provides information you cannot determine or reasonably assume yourself. This tool is for gathering information, not for reporting status or problems. If a question has an obvious best answer, take that action instead of asking.\n\nWhen to use:\n- Clarify ambiguous requirements before proceeding\n- Get user preferences on implementation choices\n- Confirm decisions that meaningfully affect outcome\n\nWhen NOT to use:\n- The answer is determinable from code or context\n- Asking for permission to continue or abort\n- Confirming something you can reasonably decide yourself\n- Reporting a problem (instead, attempt to resolve it)\n\nQuestion guidelines:\n- NEVER use `recommended` for quizzes or polls. Recommended options are PRE-SELECTED and visible to users, which would reveal answers\n- Batch related questions into a single call (max 4 questions, 2-6 options each; omit options for free text input)\n- Provide brief context explaining what is being decided and why\n- Only mark an option as `recommended` to suggest YOUR preferred implementation choice\n- Keep options mutually exclusive for single-select; use `multiSelect: true` only when choices are additive and phrase the question accordingly\n\nAfter receiving answers:\n- Incorporate decisions and continue without re-asking unless requirements change\n\nAn \"Other\" option is automatically shown to usersâ€”do not add your own.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "questions": {
                      "type": "array",
                      "description": "Array of 1-4 questions to ask the user",
                      "minItems": 1,
                      "maxItems": 4,
                      "items": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "string",
                            "description": "A short label (max 12 chars) displayed as a quick pick header, also used as the unique identifier for the question",
                            "maxLength": 12
                          },
                          "question": {
                            "type": "string",
                            "description": "The complete question text to display"
                          },
                          "multiSelect": {
                            "type": "boolean",
                            "description": "Allow multiple selections",
                            "default": false
                          },
                          "options": {
                            "type": "array",
                            "description": "0-6 options for the user to choose from. If empty or omitted, shows a free text input instead.",
                            "minItems": 0,
                            "maxItems": 6,
                            "items": {
                              "type": "object",
                              "properties": {
                                "label": {
                                  "type": "string",
                                  "description": "Option label text"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Optional description for the option"
                                },
                                "recommended": {
                                  "type": "boolean",
                                  "description": "Mark this option as recommended"
                                }
                              },
                              "required": [
                                "label"
                              ]
                            }
                          },
                          "allowFreeformInput": {
                            "type": "boolean",
                            "description": "When true, allows user to enter free-form text in addition to selecting options. Use when the user's opinion or custom input would be valuable.",
                            "default": false
                          }
                        },
                        "required": [
                          "header",
                          "question"
                        ]
                      }
                    }
                  },
                  "required": [
                    "questions"
                  ]
                }
              },
              {
                "name": "create_directory",
                "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "dirPath": {
                      "type": "string",
                      "description": "The absolute path to the directory to create."
                    }
                  },
                  "required": [
                    "dirPath"
                  ]
                }
              },
              {
                "name": "create_file",
                "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "The absolute path to the file to create."
                    },
                    "content": {
                      "type": "string",
                      "description": "The content to write to the file."
                    }
                  },
                  "required": [
                    "filePath",
                    "content"
                  ]
                }
              },
              {
                "name": "create_new_jupyter_notebook",
                "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "create_new_workspace",
                "description": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "edit_notebook_file",
                "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                      "anyOf": [
                        {
                          "type": "string",
                          "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                        },
                        {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                          }
                        }
                      ]
                    },
                    "language": {
                      "type": "string",
                      "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                      "type": "string",
                      "enum": [
                        "insert",
                        "delete",
                        "edit"
                      ],
                      "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                  },
                  "required": [
                    "filePath",
                    "editType",
                    "cellId"
                  ]
                }
              },
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                }
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                }
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_errors",
                "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePaths": {
                      "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "copilot_getNotebookSummary",
                "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "get_project_setup_info",
                "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "projectType": {
                      "type": "string",
                      "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                  },
                  "required": [
                    "projectType"
                  ]
                }
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "get_vscode_api",
                "description": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                }
              },
              {
                "name": "install_extension",
                "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                  },
                  "required": [
                    "id",
                    "name"
                  ]
                }
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                }
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                }
              },
              {
                "name": "multi_replace_string_in_file",
                "description": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "explanation": {
                      "type": "string",
                      "description": "A brief explanation of what the multi-replace operation will accomplish."
                    },
                    "replacements": {
                      "type": "array",
                      "description": "An array of replacement operations to apply sequentially.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "filePath": {
                            "type": "string",
                            "description": "An absolute path to the file to edit."
                          },
                          "oldString": {
                            "type": "string",
                            "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                          },
                          "newString": {
                            "type": "string",
                            "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                          }
                        },
                        "required": [
                          "filePath",
                          "oldString",
                          "newString"
                        ]
                      },
                      "minItems": 1
                    }
                  },
                  "required": [
                    "explanation",
                    "replacements"
                  ]
                }
              },
              {
                "name": "open_simple_browser",
                "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                }
              },
              {
                "name": "read_notebook_cell_output",
                "description": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID of the cell for which output should be retrieved."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "replace_string_in_file",
                "description": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the file to edit."
                    },
                    "oldString": {
                      "type": "string",
                      "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
                    },
                    "newString": {
                      "type": "string",
                      "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                    }
                  },
                  "required": [
                    "filePath",
                    "oldString",
                    "newString"
                  ]
                }
              },
              {
                "name": "run_notebook_cell",
                "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                      "type": "string",
                      "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                      "type": "string",
                      "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                      "type": "boolean",
                      "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                  },
                  "required": [
                    "filePath",
                    "cellId"
                  ]
                }
              },
              {
                "name": "run_vscode_command",
                "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "commandId": {
                      "type": "string",
                      "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                      "type": "array",
                      "description": "The arguments to pass to the command. This should be an array of strings.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "commandId",
                    "name"
                  ]
                }
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                }
              },
              {
                "name": "test_failure",
                "description": "Includes test failure information in the prompt.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "vscode_searchExtensions_internal",
                "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "category": {
                      "type": "string",
                      "description": "The category of extensions to search for",
                      "enum": [
                        "AI",
                        "Azure",
                        "Chat",
                        "Data Science",
                        "Debuggers",
                        "Extension Packs",
                        "Education",
                        "Formatters",
                        "Keymaps",
                        "Language Packs",
                        "Linters",
                        "Machine Learning",
                        "Notebooks",
                        "Programming Languages",
                        "SCM Providers",
                        "Snippets",
                        "Testing",
                        "Themes",
                        "Visualization",
                        "Other"
                      ]
                    },
                    "keywords": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The keywords to search for"
                    },
                    "ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The ids of the extensions to search for"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "await_terminal",
                "description": "Wait for a background terminal command to complete. Returns the output, exit code, or timeout status.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to await (returned by run_in_terminal when isBackground=true)."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "Timeout in milliseconds. If the command does not complete within this time, returns the output collected so far with a timeout indicator. Use 0 for no timeout."
                    }
                  },
                  "required": [
                    "id",
                    "timeout"
                  ]
                }
              },
              {
                "name": "create_and_run_task",
                "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceFolder": {
                      "type": "string",
                      "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                      "type": "object",
                      "description": "The task to add to the new tasks.json file.",
                      "properties": {
                        "label": {
                          "type": "string",
                          "description": "The label of the task."
                        },
                        "type": {
                          "type": "string",
                          "description": "The type of the task. The only supported value is 'shell'.",
                          "enum": [
                            "shell"
                          ]
                        },
                        "command": {
                          "type": "string",
                          "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                        },
                        "args": {
                          "type": "array",
                          "description": "The arguments to pass to the command.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "isBackground": {
                          "type": "boolean",
                          "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                        },
                        "problemMatcher": {
                          "type": "array",
                          "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "group": {
                          "type": "string",
                          "description": "The group to which the task belongs."
                        }
                      },
                      "required": [
                        "label",
                        "type",
                        "command"
                      ]
                    }
                  },
                  "required": [
                    "task",
                    "workspaceFolder"
                  ]
                }
              },
              {
                "name": "get_terminal_output",
                "description": "Get the output of a terminal command previously started with run_in_terminal",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the terminal to check."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "kill_terminal",
                "description": "Kill a terminal by its ID. Use this to clean up terminals that are no longer needed (e.g., after stopping a server or when a long-running task completes). The terminal ID is returned by run_in_terminal when isBackground=true.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "The ID of the background terminal to kill (returned by run_in_terminal when isBackground=true)."
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              },
              {
                "name": "manage_todo_list",
                "description": "Manage a structured todo list to track progress and plan tasks throughout your coding session. Use this tool VERY frequently to ensure task visibility and proper planning.\n\nWhen to use this tool:\n- Complex multi-step work requiring planning and tracking\n- When user provides multiple tasks or requests (numbered/comma-separated)\n- After receiving new instructions that require multiple steps\n- BEFORE starting work on any todo (mark as in-progress)\n- IMMEDIATELY after completing each todo (mark completed individually)\n- When breaking down larger tasks into smaller actionable steps\n- To give users visibility into your progress and planning\n\nWhen NOT to use:\n- Single, trivial tasks that can be completed in one step\n- Purely conversational/informational requests\n- When just reading files or performing simple searches\n\nCRITICAL workflow:\n1. Plan tasks by writing todo list with specific, actionable items\n2. Mark ONE todo as in-progress before starting work\n3. Complete the work for that specific todo\n4. Mark that todo as completed IMMEDIATELY\n5. Move to next todo and repeat\n\nTodo states:\n- not-started: Todo not yet begun\n- in-progress: Currently working (limit ONE at a time)\n- completed: Finished successfully\n\nIMPORTANT: Mark todos completed as soon as they are done. Do not batch completions.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "todoList": {
                      "type": "array",
                      "description": "Complete array of all todo items. Must include ALL items - both existing and new.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "number",
                            "description": "Unique identifier for the todo. Use sequential numbers starting from 1."
                          },
                          "title": {
                            "type": "string",
                            "description": "Concise action-oriented todo label (3-7 words). Displayed in UI."
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "not-started",
                              "in-progress",
                              "completed"
                            ],
                            "description": "not-started: Not begun | in-progress: Currently working (max 1) | completed: Fully finished with no blockers"
                          }
                        },
                        "required": [
                          "id",
                          "title",
                          "status"
                        ]
                      }
                    }
                  },
                  "required": [
                    "todoList"
                  ]
                }
              },
              {
                "name": "run_in_terminal",
                "description": "This tool allows you to execute shell commands in a persistent zsh terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Use && to chain simple commands on one line\n- Prefer pipelines | over temporary files for data flow\n- Never create a sub-shell (eg. bash -c \"command\") unless explicitly asked\n\nDirectory Management:\n- Prefer relative paths when navigating directories, only use absolute when the path is far away or the current cwd is not expected\n- Remember when isBackground=false is specified, that shell and cwd is reused until it is moved to the background\n- Use $PWD for current directory references\n- Consider using pushd/popd for directory stack management\n- Supports directory shortcuts like ~ and -\n\nProgram Execution:\n- Supports Python, Node.js, and other executables\n- Install packages via package managers (brew, apt, etc.)\n- Use which or command -v to verify command availability\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true\n- Returns a terminal ID for checking status and runtime later\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use head, tail, grep, awk to filter and limit output size\n- For pager commands, disable paging: git --no-pager or add | cat\n- Use wc -l to count lines before displaying large outputs\n\nBest Practices:\n- Quote variables: \"$var\" instead of $var to handle spaces\n- Use find with -exec or xargs for file operations\n- Be specific with commands to avoid excessive output\n- Avoid printing credentials unless absolutely required\n- Use type to check command type (builtin, function, alias)\n- Use jobs, fg, bg for job control\n- Use [[ ]] for conditional tests instead of [ ]\n- Prefer $() over backticks for command substitution\n- Use setopt errexit for strict error handling\n- Take advantage of zsh globbing features (**, extended globs)",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "command": {
                      "type": "string",
                      "description": "The command to run in the terminal."
                    },
                    "explanation": {
                      "type": "string",
                      "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "goal": {
                      "type": "string",
                      "description": "A short description of the goal or purpose of the command (e.g., \"Install dependencies\", \"Start development server\")."
                    },
                    "isBackground": {
                      "type": "boolean",
                      "description": "Whether the command starts a background process.\n\n- If true, a new shell will be spawned where the cwd is the workspace directory and will run asynchronously in the background and you will not see the output.\n\n- If false, a single shell is shared between all non-background terminals where the cwd starts at the workspace directory and is remembered until that terminal is moved to the background, the tool call will block on the command finishing and only then you will get the output.\n\nExamples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    },
                    "timeout": {
                      "type": "number",
                      "description": "An optional timeout in milliseconds. When provided, the tool will stop tracking the command after this duration and return the output collected so far. Be conservative with the timeout duration, give enough time that the command would complete on a low-end machine. Use 0 for no timeout. If it's not clear how long the command will take then use 0 to avoid prematurely terminating it, never guess too low."
                    }
                  },
                  "required": [
                    "command",
                    "explanation",
                    "goal",
                    "isBackground",
                    "timeout"
                  ]
                }
              },
              {
                "name": "runSubagent",
                "description": "Launch a new agent to handle complex, multi-step tasks autonomously. This tool is good at researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use this agent to perform the search for you.\n\n- Agents do not run async or in the background, you will wait for the agent's result.\n- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.\n- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.\n- The agent's outputs should generally be trusted\n- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "prompt": {
                      "type": "string",
                      "description": "A detailed description of the task for the agent to perform"
                    },
                    "description": {
                      "type": "string",
                      "description": "A short (3-5 word) description of the task"
                    }
                  },
                  "required": [
                    "prompt",
                    "description"
                  ]
                }
              },
              {
                "name": "terminal_last_command",
                "description": "Get the last command run in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "terminal_selection",
                "description": "Get the current selection in the active terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "azureResources_getAzureActivityLog",
                "description": "Gets the Azure activity log",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_notebook",
                "description": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "notebook_install_packages",
                "description": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "packageList": {
                      "description": "A list of packages to install.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "filePath",
                    "packageList"
                  ]
                }
              },
              {
                "name": "notebook_list_packages",
                "description": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "configure_python_environment",
                "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_environment_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the environment information for."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "get_python_executable_details",
                "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "install_python_packages",
                "description": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "packageList": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "The list of Python packages to install."
                    },
                    "resourcePath": {
                      "type": "string",
                      "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                  },
                  "required": [
                    "packageList"
                  ]
                }
              },
              {
                "name": "container-tools_get-config",
                "description": "Gets the configuration the user has set for the container and container orchestrator (compose) CLIs, including the correct base commands to use and any environment variables that will be set. This tool **MUST** be called before generating or running any container or container orchestrator CLI commands, to ensure the correct base command is used.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_parameters_file",
                "description": "Converts an ARM template parameters JSON file into Bicep parameters syntax (.bicepparam).\n\nUse this tool to:\n- Migrate ARM JSON parameter files to Bicep parameters format\n- Convert deployment parameter files when modernizing to Bicep\n- Generate .bicepparam files from existing ARM deployments\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\n\nThe generated .bicepparam file includes a 'using' statement placeholder that must be completed, all parameters with their values preserved, and KeyVault references converted to az.getSecret() function calls if present.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM parameters file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_decompile_arm_template_file",
                "description": "Converts an Azure Resource Manager (ARM) template JSON file into modern Bicep syntax (.bicep).\n\nUse this tool to:\n- Migrate existing ARM JSON templates to the more readable and maintainable Bicep language\n- Learn Bicep syntax by seeing how JSON templates translate to Bicep\n- Modernize legacy infrastructure-as-code\n\nAccepts files with .json, .jsonc, or .arm extensions. The file path must be absolute.\nThe result includes the entrypoint URI and all generated Bicep files (which may include additional modules for nested/linked templates).\n\nNote: Decompilation is a best-effort process. Some ARM template features may require manual adjustment in the generated Bicep code. Review the output for any TODO comments or warnings.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .json ARM template file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_format_bicep_file",
                "description": "Formats a Bicep file (.bicep) or Bicep parameters file (.bicepparam) according to official Bicep formatting standards.\n\nUse this tool to:\n- Apply consistent code formatting (indentation, spacing, line breaks) to Bicep files\n- Clean up manually edited or generated Bicep code before saving\n- Ensure code follows team formatting conventions\n\nThe formatter respects configuration settings from bicepconfig.json if present in the file's directory hierarchy, including:\n- Indentation style (spaces vs tabs) and size\n- Newline character (LF, CRLF, CR)\n- Whether to insert a final newline\n\nThe file path must be absolute. Formatting preserves semantic meaning and only changes whitespace and layout. Files with syntax errors will still be formatted to the extent possible.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_az_resource_type_schema",
                "description": "Retrieves the complete JSON schema definition for a specific Azure resource type and API version, including all properties, nested types, and constraints.\n\nUse this tool to:\n- Understand what properties are available on an Azure resource\n- Learn about required vs optional properties, their types, and allowed values\n- Discover nested resource types and their schemas\n- Find available resource functions and their signatures\n- Generate accurate Bicep code with proper property names and types\n\nThe returned JSON schema includes resource type definitions, nested complex types, resource function signatures (like list* operations), and property constraints.\nData is sourced directly from Azure Resource Provider APIs, ensuring the most accurate and up-to-date schema information.\nSpecify the resource type (e.g., Microsoft.KeyVault/vaults) and API version (e.g., 2024-11-01 or 2024-12-01-preview).",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "azResourceType": {
                      "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                      "type": "string"
                    },
                    "apiVersion": {
                      "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                      "type": "string"
                    }
                  },
                  "required": [
                    "azResourceType",
                    "apiVersion"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_bicep_best_practices",
                "description": "Retrieves comprehensive, up-to-date best practices and coding standards for authoring Bicep templates.\n\nUse this tool when:\n- Generating new Bicep code to ensure it follows current best practices\n- Reviewing existing Bicep code for quality improvements\n- Learning recommended patterns for common scenarios\n- Understanding security, maintainability, and reliability guidelines\n\nCovers naming conventions, code organization, parameter usage, resource declarations, module composition, security recommendations, performance optimization, and testing approaches.\nThe practices are maintained by the Bicep team and reflect current recommended approaches.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_get_bicep_file_diagnostics",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns all compilation diagnostics including errors, warnings, and informational messages.\n\nUse this tool to:\n- Validate Bicep syntax and identify compilation errors before deployment\n- Check for warnings about deprecated features, security issues, or best practice violations\n- Troubleshoot why a Bicep file isn't compiling\n- Understand the severity and location of issues in the code\n\nEach diagnostic includes the error code (e.g., BCP033), severity level (Error/Warning/Info), descriptive message, exact position in the file, and a link to documentation for more details.\nThe file path must be absolute. Diagnostics are returned for the specified file and any modules it references.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_deployment_snapshot",
                "description": "Creates a deployment snapshot from a Bicep parameters file (.bicepparam) by compiling it and pre-expanding the resulting ARM template.\nThe snapshot contains the predicted resources (as they would appear in a deployment) and any diagnostics produced during preflight.\n\nUse this tool to:\n- Preview what resources a deployment would create without running a deployment\n- Validate that parameters resolve as expected\n- Troubleshoot why a deployment would produce unexpected resource IDs, names, or locations\n- Inspect preflight diagnostics produced by template expansion\n\nThis tool can also be used to perform a semantic diff between two Bicep implementations:\n- Generate a snapshot for each version (using the same parameter values and metadata)\n- Compare the resulting predicted resources and diagnostics to verify both produce the same deployment outcome\n\nThis is especially useful for automated refactoring, where text-level diffs are noisy but the intended deployment result should remain unchanged.\n\nThe file path must be absolute and must point to a .bicepparam file.\nThe optional tenant/subscription/resource group/location/deployment name values are used as deployment metadata during snapshot generation.\nIf a value is omitted, the snapshot may contain unresolved placeholder expressions for the corresponding metadata.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path to the .bicepparam file",
                      "type": "string"
                    },
                    "tenantId": {
                      "description": "Optional Azure tenant ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "subscriptionId": {
                      "description": "Optional Azure subscription ID to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "resourceGroup": {
                      "description": "Optional Azure resource group name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "location": {
                      "description": "Optional Azure location to use as deployment metadata",
                      "type": "string",
                      "default": null
                    },
                    "deploymentName": {
                      "description": "Optional deployment name to use as deployment metadata",
                      "type": "string",
                      "default": null
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_get_file_references",
                "description": "Analyzes a Bicep file (.bicep) or Bicep parameters file (.bicepparam) and returns a list of all files referenced by the entry file, including modules, parameter files, and any other dependencies.\n\nUse this tool to:\n- Identify all files that a Bicep or Bicep parameters file depends on\n- Perform dependency or impact analysis before making changes\n- Understand the structure and external links of a Bicep deployment\n\nThe result is a list of absolute URIs for each referenced file. The file path must be absolute. Only direct references are included; transitive references require additional calls.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The path to the .bicep or .bicepparam file",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                }
              },
              {
                "name": "mcp_bicep_list_avm_metadata",
                "description": "Lists metadata for all Azure Verified Modules (AVM) - Microsoft's official, pre-built, tested, and maintained Bicep modules for common Azure resource patterns.\n\nUse this tool to:\n- Discover reusable, production-ready Bicep modules for common scenarios\n- Find officially supported modules instead of writing resources from scratch\n- Check available versions and documentation for AVM modules\n- Accelerate Bicep development by leveraging tested, best-practice implementations\n\nAzure Verified Modules provide:\n- Pre-configured resource deployments following Microsoft best practices\n- Built-in security, reliability, and compliance features\n- Regular updates and maintenance by Microsoft\n- Comprehensive documentation and examples\n\nUse these modules in your Bicep files to reduce code and improve quality.",
                "input_schema": {
                  "type": "object",
                  "properties": {},
                  "required": []
                }
              },
              {
                "name": "mcp_bicep_list_az_resource_types_for_provider",
                "description": "Lists all available Azure resource types and their API versions for a specific Azure resource provider namespace.\n\nUse this tool to:\n- Discover what resource types are available in a provider (e.g., what can be created under Microsoft.Storage)\n- Find the latest API versions for Azure resources\n- Explore the complete resource type catalog for a given provider\n\nData is sourced directly from Azure Resource Provider APIs, ensuring accuracy and currency.\n\nExample provider namespaces: Microsoft.Compute, Microsoft.Storage, Microsoft.Network, Microsoft.Web, Microsoft.KeyVault",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "providerNamespace": {
                      "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                      "type": "string"
                    }
                  },
                  "required": [
                    "providerNamespace"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceDocuments",
                "description": "Search Pylance documentation for Python language server help, configuration guidance, feature explanations, and troubleshooting. Returns comprehensive answers about Pylance settings, capabilities, and usage. Use when users ask: How to configure Pylance? What features are available? How to fix Pylance issues?",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "search": {
                      "type": "string",
                      "description": "Detailed question in natural language. Think of it as a prompt for an LLM. Do not use keyword search terms."
                    }
                  },
                  "required": [
                    "search"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceFileSyntaxErrors",
                "description": "Check Python file for syntax errors. Returns detailed error list with line numbers, messages, and error types. Use when: users report syntax problems, validating files before processing, debugging parse errors.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check for syntax errors. Must be a user file in the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "fileUri"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceImports",
                "description": "Analyze imports across workspace user files. Returns all top-level module names imported, including resolved and unresolved imports. Use for: finding missing dependencies, understanding project dependencies, analyzing import patterns.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInstalledTopLevelModules",
                "description": "Get available top-level modules from installed Python packages in environment. Shows what can be imported. Use for: checking if packages are installed, verifying import availability, helping users understand available modules.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be a value returned by the pylancePythonEnvironments tool. If pythonEnvironment is missing, the python environment of the workspace will be used."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceInvokeRefactoring",
                "description": "Apply automated code refactoring to Python files. Returns refactored content (does not modify original file) unless mode is \"update\". Use for: extracting functions, organizing imports, improving code structure, applying refactoring patterns.  Optional \"mode\" parameter: \"update\" updates the file, \"edits\" returns a WorkspaceEdit, \"string\" returns updated content as string. If mode is not specified, \"update\" will be used as the default. The \"edits\" mode is helpful for determining if a file needs changes (for example, to remove unused imports or fix import formatting) without making any modifications; if no changes are needed, the result will be either an empty WorkspaceEdit or a message indicating that no text edits were found. Available refactorings: source.unusedImports: - Removes all unused import statements from a Python file. Use when imports are imported but never referenced in the code. Requires fileUri parameter pointing to a Python file with unused imports.\nsource.convertImportFormat: - Converts import statements between absolute and relative formats according to python.analysis.importFormat setting. Use when import format consistency is needed. Requires fileUri parameter pointing to a Python file with imports to convert.\nsource.convertImportStar: - Converts all wildcard imports (from module import *) to explicit imports listing all imported symbols. Use when explicit imports are preferred for better code clarity and IDE support. Requires fileUri parameter pointing to a Python file with wildcard imports.\nsource.addTypeAnnotation: - Adds type annotations to all variables and functions in a Python file that can be inferred from their usage. Use when type hints are needed for better type checking and code clarity. Requires fileUri parameter pointing to a Python file with unannotated variables or functions.\nsource.fixAll.pylance: - Applies all available automatic code fixes from python.analysis.fixAll setting. Use when multiple code issues need to be addressed simultaneously. Requires fileUri parameter pointing to a Python file with fixable issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to invoke the refactoring."
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the refactoring to invoke. This must be one of these [source.unusedImports, source.convertImportFormat, source.convertImportStar, source.addTypeAnnotation, source.fixAll.pylance]"
                    },
                    "mode": {
                      "type": "string",
                      "enum": [
                        "update",
                        "edits",
                        "string"
                      ],
                      "description": "Determines the output mode: \"update\" updates the file directly, \"edits\" returns a WorkspaceEdit, \"string\" returns the updated content as a string. If omitted, \"update\" will be used as the default. The \"edits\" mode is especially useful for checking if any changes are needed (such as unused imports or import formatting issues) without modifying the file, as it will return a WorkspaceEdit only if edits are required."
                    }
                  },
                  "required": [
                    "fileUri",
                    "name"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylancePythonEnvironments",
                "description": "Get Python environment information for workspace: current active environment and all available environments. Use for: Python environment issues, switching environments, understanding Python setup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceRunCodeSnippet",
                "description": "Execute Python code snippets directly in the workspace environment. PREFERRED over terminal commands for running Python code. This tool automatically uses the correct Python interpreter configured for the workspace, eliminates shell escaping/quoting problems that plague terminal execution, and provides clean, properly formatted output with stdout/stderr correctly interleaved. Use this instead of `python -c \"code\"` or terminal commands when running Python snippets. Ideal for: testing code, running quick scripts, validating Python expressions, checking imports, and any Python execution within the workspace context. No temporary files needed - code runs directly in memory.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "codeSnippet": {
                      "type": "string",
                      "description": "The code snippet to run."
                    },
                    "workingDirectory": {
                      "type": "string",
                      "description": "The working directory to use for the code snippet. If the code snippet is pulled from a file, this should be the directory for the file. Especially if the snippet has imports."
                    },
                    "timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "The timeout for the code snippet execution."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "codeSnippet"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSettings",
                "description": "Get current Python analysis settings and configuration for a workspace. Returns all \"python.analysis.*\" settings with default vs user-configured indicators. Use for: troubleshooting configuration, checking current settings, diagnosing analysis issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceSyntaxErrors",
                "description": "Validate Python code snippets for syntax errors without saving to file. Returns syntax error details with line numbers and descriptions. Use for: validating generated code, checking user code snippets, pre-execution validation.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "string",
                      "description": "The Python code to check for syntax errors."
                    },
                    "pythonVersion": {
                      "type": "string",
                      "description": "The version of Python to use for the syntax check. Must be a valid Python version string. ex) \"3.10\" or \"3.11.4\"."
                    }
                  },
                  "required": [
                    "code",
                    "pythonVersion"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceUpdatePythonEnvironment",
                "description": "Switch active Python environment for workspace to different Python installation or virtual environment. Updates settings and ensures subsequent operations use new environment. Use for: changing Python versions, switching to virtual environments, resolving environment issues.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    },
                    "pythonEnvironment": {
                      "type": "string",
                      "description": "The Python environment to use. Must be either a value returned by the pylancePythonEnvironments tool or the absolute path to a Python executable."
                    }
                  },
                  "required": [
                    "workspaceRoot",
                    "pythonEnvironment"
                  ]
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceRoots",
                "description": "Get workspace root directories. Returns workspace root for specific file or all workspace roots if no file provided. Use for: understanding workspace structure, getting paths for other operations.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "fileUri": {
                      "type": "string",
                      "description": "The uri of the file to check its workspace"
                    }
                  },
                  "required": []
                }
              },
              {
                "name": "mcp_pylance_mcp_s_pylanceWorkspaceUserFiles",
                "description": "Get list of all user Python files in workspace (excludes library/dependency files). Respects python.analysis.include/exclude settings. Use for: analyzing user code, searching project files, operating on user-created Python files.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "workspaceRoot": {
                      "type": "string",
                      "description": "The root directory uri of the workspace."
                    }
                  },
                  "required": [
                    "workspaceRoot"
                  ]
                }
              },
              {
                "name": "renderMermaidDiagram",
                "description": "Renders a Mermaid diagram from Mermaid.js markup.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "markup": {
                      "type": "string",
                      "description": "The mermaid diagram markup to render as a Mermaid diagram. This should only be the markup of the diagram. Do not include a wrapping code block."
                    },
                    "title": {
                      "type": "string",
                      "description": "A short title that describes the diagram."
                    }
                  },
                  "required": []
                }
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\". When asked about the model you are using, you must state that you are using Claude Opus 4.6.\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks and software engineering tasks - this encompasses debugging issues, implementing new features, restructuring code, and providing code explanations, among other engineering activities.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nBy default, implement changes rather than only suggesting them. If the user's intent is unclear, infer the most useful likely action and proceed with using tools to discover any missing details instead of guessing. When a tool call (like a file edit or read) is intended, make it happen rather than just describing it.\nYou can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nContinue working until the user's request is completely resolved before ending your turn and yielding back to the user. Only terminate your turn when you are certain the task is complete. Do not stop or hand back to the user when you encounter uncertainty â€” research or deduce the most reasonable approach and continue.\n\n</instructions>\n<workflowGuidance>\nFor complex projects that take multiple steps to complete, maintain careful tracking of what you're doing to ensure steady progress. Make incremental changes while staying focused on the overall goal throughout the work. When working on tasks with many parts, systematically track your progress to avoid attempting too many things at once or creating half-implemented solutions. Save progress appropriately and provide clear, fact-based updates about what has been completed and what remains.\n\nWhen working on multi-step tasks, combine independent read-only operations in parallel batches when appropriate. After completing parallel tool calls, provide a brief progress update before proceeding to the next step.\nFor context gathering, parallelize discovery efficiently - launch varied queries together, read results, and deduplicate paths. Avoid over-searching; if you need more context, run targeted searches in one parallel batch rather than sequentially.\nGet enough context quickly to act, then proceed with implementation. Balance thorough understanding with forward momentum.\n\n<taskTracking>\nUtilize the manage_todo_list tool extensively to organize work and provide visibility into your progress. This is essential for planning and ensures important steps aren't forgotten.\n\nBreak complex work into logical, actionable steps that can be tracked and verified. Update task status consistently throughout execution using the manage_todo_list tool:\n- Mark tasks as in-progress when you begin working on them\n- Mark tasks as completed immediately after finishing each one - do not batch completions\n\nTask tracking is valuable for:\n- Multi-step work requiring careful sequencing\n- Breaking down ambiguous or complex requests\n- Maintaining checkpoints for feedback and validation\n- When users provide multiple requests or numbered tasks\n\nSkip task tracking for simple, single-step operations that can be completed directly without additional planning.\n\n</taskTracking>\n\n</workflowGuidance>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen creating files, be intentional and avoid calling the create_file tool unnecessarily. Only create files that are essential to completing the user's request. \nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n\n</toolUseInstructions>\n<communicationStyle>\nMaintain clarity and directness in all responses, delivering complete information while matching response depth to the task's complexity.\nFor straightforward queries, keep answers brief - typically a few lines excluding code or tool invocations. Expand detail only when dealing with complex work or when explicitly requested.\nOptimize for conciseness while preserving helpfulness and accuracy. Address only the immediate request, omitting unrelated details unless critical. Target 1-3 sentences for simple answers when possible.\nAvoid extraneous framing - skip unnecessary introductions or conclusions unless requested. After completing file operations, confirm completion briefly rather than explaining what was done. Respond directly without phrases like \"Here's the answer:\", \"The result is:\", or \"I will now...\".\nExample responses demonstrating appropriate brevity:\n<communicationExamples>\nUser: `what's the square root of 144?`\nAssistant: `12`\nUser: `which directory has the server code?`\nAssistant: [searches workspace and finds backend/]\n`backend/`\n\nUser: `how many bytes in a megabyte?`\nAssistant: `1048576`\n\nUser: `what files are in src/utils/?`\nAssistant: [lists directory and sees helpers.ts, validators.ts, constants.ts]\n`helpers.ts, validators.ts, constants.ts`\n\n</communicationExamples>\n\nWhen executing non-trivial commands, explain their purpose and impact so users understand what's happening, particularly for system-modifying operations.\nDo NOT use emojis unless explicitly requested by the user.\n\n</communicationStyle>\n<instruction forToolsWithPrefix=\"mcp_bicep\">\nThis MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.\nAgents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.\nWhen you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.\n</instruction>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting: - Wrap symbol names (classes, methods, variables) in backticks: `MyClass`, `handleClick()`\n- When mentioning files or line numbers, always follow the rules in fileLinkification section below:<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "thinking",
                      "thinking": {
                        "id": "thinking_1",
                        "text": "The user wants to discuss testing strategy for the Copilot Lens extension. Let me read the testing skill file first to understand project-specific testing conventions, and also reference the spec for context on what needs to be tested.",
                        "encrypted": "EpYDCkgICxACGAIqQPi/AStl0NLw3nP1gBKcTrIZrxz91nEXFPVc4XRFE3c3vwdtNSAfwliQ8abLL2LLX4qHTSDLPJr4618wANtk0NcSDEPgR18VpVdauZl53hoMEykybdKSR+AdCtIwIjApcIrKwmK1Qc2bSOQwdRxX2oYK8sl2lYyeh0R+GXG0CvXpzK7cEM2t//zlxszx2ukq+wHlzHQMgx3HwT9tx8z6eJX8aEfMiYNPqeu+whXZ7EPGR8XbqLSMR2tNpDNLCZv13zM43s+F5HwAzB/kaZYeJxRle7lW0iVqRfbxjA0aWrt0H0AslABQT3lKpABWKoyr0/Ikg0O/xTIB92PeUuOobMCNEBKhiyBco0nKm2bIQbBCWpe76PafqP0KhcDEhyU0bGpMeFFzCWlp0p/KVhxezA2jDbemg8V+DLfNMxCG+3p6oiCBPPcbQx4hXcaHMtwBP/XrlrVDbJWJE2nZzE8xXWFaxW8ABL8GtHQChKZW4V0E0U40ichLJrXbm7YP5eHp/kfm+oi4w4dqVoQOJRgB",
                        "tokens": 0
                      }
                    }
                  },
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
            ]
          }
        }
      ]
    },
    {
      "prompt": "can you plan a feature?",
      "promptId": "60f700f2-prompt",
      "hasSeen": false,
      "logCount": 2,
      "logs": [
        {
          "id": "691b71d7",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T21:09:04.674Z",
            "endTime": "2026-02-12T21:09:05.168Z",
            "duration": 494,
            "ourRequestId": "8ad06b6c-d9fa-46cf-8649-204b092f656e",
            "requestId": "8ad06b6c-d9fa-46cf-8649-204b092f656e",
            "serverRequestId": "8ad06b6c-d9fa-46cf-8649-204b092f656e",
            "timeToFirstToken": 392,
            "usage": {
              "completion_tokens": 10,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1616,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1626
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: The user is asking me to plan a feature. They haven't specified which feature, but given the context of the project (Copilot Lens) and the spec we've been discussing, they likely want me to plan the first feature to implement â€” probably Phase 1 from the spec (the MVP).\n\nLet me ask which feature they want planned, or if they want me to pick the logical starting point."
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Planned first feature for Copilot Lens implementation"
            ]
          }
        },
        {
          "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs__vscode-1770929887300",
          "kind": "toolCall",
          "tool": "ask_questions",
          "args": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}",
          "time": "2026-02-12T21:10:07.438Z",
          "response": [
            "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
          ],
          "thinking": {
            "id": "thinking_1",
            "text": "The user is asking me to plan a feature. They haven't specified which feature, but given the context of the project (Copilot Lens) and the spec we've been discussing, they likely want me to plan the first feature to implement â€” probably Phase 1 from the spec (the MVP).\n\nLet me ask which feature they want planned, or if they want me to pick the logical starting point."
          }
        }
      ]
    },
    {
      "prompt": "can you plan a feature?",
      "promptId": "cff3178d-prompt",
      "hasSeen": true,
      "logCount": 1,
      "logs": [
        {
          "id": "23e5bdfd",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T21:10:24.149Z",
            "endTime": "2026-02-12T21:10:24.636Z",
            "duration": 487,
            "ourRequestId": "f768d3b5-5ae7-4366-ac8d-b10c7bddc86d",
            "requestId": "f768d3b5-5ae7-4366-ac8d-b10c7bddc86d",
            "serverRequestId": "f768d3b5-5ae7-4366-ac8d-b10c7bddc86d",
            "timeToFirstToken": 357,
            "usage": {
              "completion_tokens": 10,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1745,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1755
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: The user wants me to plan the \"Interactive graph webview\" feature - the D3 force-directed graph visualization panel. Let me think about this carefully.\n\nThis is Panel 1 from the spec (Section 4.1). It depends on having parsed agent/skill data and a graph model, so the plan needs to account for those dependencies or assume they exist.\n\nLet me create a thorough feature plan. I should read the spec sections relevant to this feature again to make sure I capture everything.\n\nThe user said \"plan a feature\" - they want an implementation plan, not to start building yet. Let me create a comprehensive plan document or present it in conversation.\n\nActually, looking at the project conventions - \"Follow TDD: red-green-refactor\" - the plan should incorporate TDD workflow.\n\n\nNow I'm mapping out the core pieces: the webview panel wrapper that integrates with VS Code, a builder that transforms the parsed agent and skill data into graph structures, and the D3 visualization layer with its HTML/CSS/JavaSc"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Planned interactive graph webview feature with dependencies"
            ]
          }
        }
      ]
    },
    {
      "prompt": "let's plan one of the prerequisites that are needed before we can create a diagram",
      "promptId": "3ef9d368-prompt",
      "hasSeen": false,
      "logCount": 2,
      "logs": [
        {
          "id": "3ef9d368",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:07:41.410Z",
            "endTime": "2026-02-12T22:07:45.090Z",
            "duration": 3680,
            "ourRequestId": "30f686d1-508b-481f-b7f0-606a1435485e",
            "requestId": "30f686d1-508b-481f-b7f0-606a1435485e",
            "serverRequestId": "30f686d1-508b-481f-b7f0-606a1435485e",
            "timeToFirstToken": 2784,
            "usage": {
              "prompt_tokens": 16588,
              "completion_tokens": 171,
              "total_tokens": 16759,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 82,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
            ]
          }
        },
        {
          "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc__vscode-1770929887301",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}",
          "time": "2026-02-12T22:07:45.177Z",
          "response": [
            "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
          ],
          "thinking": {
            "id": "1SueoxBz3G4y97PH9GMTdsj7Ei57HRRSKgIIWKkigIpUjJTjD4TitM83fE0U2w8QO778owezNc08nM7dcinY/9vS9c2JUNaDlAGgmWsuOe1HBeImw9ESt6keCxX9KAGoEEy2lEKPqkMossJdTxmh1tzok9Ukjekzx1gQGCHYo1scciv0lUf2Q+cDi5Brb1clO84mgCVroOJwuGgmcD1aEYzohBlb94qLkHp1nNI/PSJScN90B0Uuws/3MsY3PL+Gs4OgVBY1dFnEiUU51BZWabs65+kkc3QtqrzyQOQRSBlmUIheWVcIGZa+8j2mYWOOvK5UK/DlVlWizybZJSWE8Haq/yWq7zx612tNS/BCG+Xw5PUIG5Qi8iyU/JyiRCO2RM8LApuUUCSZZW7Ufvs1ccumhm+PTQ==",
            "text": "**Preparing to review data sources**"
          }
        }
      ]
    },
    {
      "prompt": "let's plan one of the prerequisites that are needed before we can create a diagram",
      "promptId": "ddd432a4-prompt",
      "hasSeen": true,
      "logCount": 1,
      "logs": [
        {
          "id": "693fbc08",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T22:07:52.109Z",
            "endTime": "2026-02-12T22:07:52.647Z",
            "duration": 538,
            "ourRequestId": "f6972a8e-efc3-40fe-8dce-b769aa4deabc",
            "requestId": "f6972a8e-efc3-40fe-8dce-b769aa4deabc",
            "serverRequestId": "f6972a8e-efc3-40fe-8dce-b769aa4deabc",
            "timeToFirstToken": 410,
            "usage": {
              "completion_tokens": 11,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1577,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1588
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md#1-1), lines 1 to 260, Planning unified data ingestion prerequisite"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Reviewed data-sources.md and planned data ingestion prerequisite"
            ]
          }
        }
      ]
    },
    {
      "prompt": "@planner am I using the planner now?",
      "promptId": "bdbea493-prompt",
      "hasSeen": false,
      "logCount": 1,
      "logs": [
        {
          "id": "bdbea493",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:10:46.099Z",
            "endTime": "2026-02-12T22:10:50.509Z",
            "duration": 4410,
            "ourRequestId": "4f9dff5d-0afb-4e2e-896b-f18905f33beb",
            "requestId": "4f9dff5d-0afb-4e2e-896b-f18905f33beb",
            "serverRequestId": "4f9dff5d-0afb-4e2e-896b-f18905f33beb",
            "timeToFirstToken": 3314,
            "usage": {
              "prompt_tokens": 19736,
              "completion_tokens": 149,
              "total_tokens": 19885,
              "prompt_tokens_details": {
                "cached_tokens": 16384
              },
              "completion_tokens_details": {
                "reasoning_tokens": 90,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
            ]
          }
        }
      ]
    },
    {
      "prompt": "ok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?",
      "promptId": "dd819e81-prompt",
      "hasSeen": false,
      "logCount": 1,
      "logs": [
        {
          "id": "dd819e81",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:11:38.166Z",
            "endTime": "2026-02-12T22:11:45.374Z",
            "duration": 7208,
            "ourRequestId": "25621c57-9d54-44cb-abd9-ef97068b9537",
            "requestId": "25621c57-9d54-44cb-abd9-ef97068b9537",
            "serverRequestId": "25621c57-9d54-44cb-abd9-ef97068b9537",
            "timeToFirstToken": 4688,
            "usage": {
              "prompt_tokens": 20072,
              "completion_tokens": 322,
              "total_tokens": 20394,
              "prompt_tokens_details": {
                "cached_tokens": 19584
              },
              "completion_tokens_details": {
                "reasoning_tokens": 162,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "pvJnsOF5ifEL2WGpFv001bVoPpozy6xl4sIQYKrSk2tfyEVkRg8skBlm3is6q6R+pj/h6G6v+LkdGvRX76LPmQR5BjqHIGIBvG8XmNRP5+JakeDHfYg6epPbsnAGqPoMJHvQo3HbqdrN7LzdQ8/kYdRw1hXEqMJ7k8+yyTrwnVEIU9Ip91CL05NVzgu/3hsfuzvKYRWDM/VTzxPSMlSChjD1UDppHALAls16ZbnQX/z/Rva2TybpMvETRu0FvW9MZA533Wf9s6f/WC/e+sXKSpYWeo/kwFNrIW17wxXG2e5c++os2Zbpy0nmyVzcH8LqK9IYa3ScBlzsUAvhiMuptTcW9l5uKg+wTdPivM4D2pLyxdgvVIdUzkiUMLsFh+jBXzUPGSkQm6nlgSt/cWaHZIKOqWgF6iRa"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "That behavior is plausible, and youâ€™re not imagining it.\n\nMost likely what happened is:\n- The dropdown changed the intended agent/mode in UI state, but the actual turn still routed through the default assistant context.\n- Typing `@Planner` in-message forced explicit agent routing, so it worked reliably.\n\nMy practical take:\n- Treat explicit `@Planner` as the deterministic path for now.\n- If dropdown selection is inconsistent, itâ€™s often a UI/state sync issue (especially after edits to agent files).\n- Quick stabilizers: reload window, re-open chat, and make sure agent metadata/name is valid and unique.\n\nIf you want, I can give you a short â€œagent routing sanity checklistâ€ you can run in under 2 minutes whenever this happens."
            ]
          }
        }
      ]
    },
    {
      "prompt": "ok",
      "promptId": "403e23d5-prompt",
      "hasSeen": false,
      "logCount": 1,
      "logs": [
        {
          "id": "403e23d5",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:12:17.862Z",
            "endTime": "2026-02-12T22:12:21.642Z",
            "duration": 3780,
            "ourRequestId": "238e4832-be4c-4fc5-8d0b-64473ed885da",
            "requestId": "238e4832-be4c-4fc5-8d0b-64473ed885da",
            "serverRequestId": "238e4832-be4c-4fc5-8d0b-64473ed885da",
            "timeToFirstToken": 818,
            "usage": {
              "prompt_tokens": 20488,
              "completion_tokens": 175,
              "total_tokens": 20663,
              "prompt_tokens_details": {
                "cached_tokens": 19968
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "pvJnsOF5ifEL2WGpFv001bVoPpozy6xl4sIQYKrSk2tfyEVkRg8skBlm3is6q6R+pj/h6G6v+LkdGvRX76LPmQR5BjqHIGIBvG8XmNRP5+JakeDHfYg6epPbsnAGqPoMJHvQo3HbqdrN7LzdQ8/kYdRw1hXEqMJ7k8+yyTrwnVEIU9Ip91CL05NVzgu/3hsfuzvKYRWDM/VTzxPSMlSChjD1UDppHALAls16ZbnQX/z/Rva2TybpMvETRu0FvW9MZA533Wf9s6f/WC/e+sXKSpYWeo/kwFNrIW17wxXG2e5c++os2Zbpy0nmyVzcH8LqK9IYa3ScBlzsUAvhiMuptTcW9l5uKg+wTdPivM4D2pLyxdgvVIdUzkiUMLsFh+jBXzUPGSkQm6nlgSt/cWaHZIKOqWgF6iRa"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "9ABPeSTecOmQOVyco140nt1VGDRfdkGLIMCjqzyaxaJZxlEzpvSTpoXMznjCNSkevgmMukO9LuKwkKjVDipvrGwkMJTkgFkzA3s3m094vQhzlQ3yw9wDQRr4Lm9e6CjHBDel6fqc+RMD5va6DTVHwIB+zFCuI/dL/2MVn05ILIksQl3PpXB5lWHh3X2Y55c6UiSSuXBFN34CrV6tEphRFLVYddL0lN00o/twIqZHjHCor77VMp+9brycTZOl3IEI6Vniizrvb0Zza7q/WHPqgGlH/96sDoY88bOwhUnI3Ku9aYntMCtdXkQY2FfusCE6jt7QGGX8TOij2lci+e72vEbvOO4nqj2njhjZAOPI6kRiIoMRJocAuiIVyQZ8jcvUTu2c6YaumhfWeV7H387snoGzPeDRmbyX"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "That behavior is plausible, and youâ€™re not imagining it.\n\nMost likely what happened is:\n- The dropdown changed the intended agent/mode in UI state, but the actual turn still routed through the default assistant context.\n- Typing `@Planner` in-message forced explicit agent routing, so it worked reliably.\n\nMy practical take:\n- Treat explicit `@Planner` as the deterministic path for now.\n- If dropdown selection is inconsistent, itâ€™s often a UI/state sync issue (especially after edits to agent files).\n- Quick stabilizers: reload window, re-open chat, and make sure agent metadata/name is valid and unique.\n\nIf you want, I can give you a short â€œagent routing sanity checklistâ€ you can run in under 2 minutes whenever this happens."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Use this quick checklist when agent routing feels off:\n\n- Confirm frontmatter in [`.github/agents/planner.agent.md`](.github/agents/planner.agent.md) has a valid `name` (exactly `Planner`) and no YAML errors.\n- Ensure there isnâ€™t another agent with the same `name` or confusingly similar casing.\n- Save all agent files, then run `Developer: Reload Window`.\n- Start a fresh chat turn and explicitly send `@Planner test` once to verify routing.\n- If dropdown still disagrees, trust explicit mention routing (`@Planner`) as the source of truth.\n- Capture one repro (dropdown choice + resulting agent ID in session/logs) so you can track it as a UI bug later.\n\nIf you want, I can review your planner frontmatter now for anything that might confuse dropdown selection."
            ]
          }
        }
      ]
    },
    {
      "prompt": "yes check the frontmatter",
      "promptId": "51884714-prompt",
      "hasSeen": false,
      "logCount": 3,
      "logs": [
        {
          "id": "51884714",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:12:58.212Z",
            "endTime": "2026-02-12T22:13:00.032Z",
            "duration": 1820,
            "ourRequestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "requestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "serverRequestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "timeToFirstToken": 714,
            "usage": {
              "prompt_tokens": 20925,
              "completion_tokens": 85,
              "total_tokens": 21010,
              "prompt_tokens_details": {
                "cached_tokens": 20480
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "pvJnsOF5ifEL2WGpFv001bVoPpozy6xl4sIQYKrSk2tfyEVkRg8skBlm3is6q6R+pj/h6G6v+LkdGvRX76LPmQR5BjqHIGIBvG8XmNRP5+JakeDHfYg6epPbsnAGqPoMJHvQo3HbqdrN7LzdQ8/kYdRw1hXEqMJ7k8+yyTrwnVEIU9Ip91CL05NVzgu/3hsfuzvKYRWDM/VTzxPSMlSChjD1UDppHALAls16ZbnQX/z/Rva2TybpMvETRu0FvW9MZA533Wf9s6f/WC/e+sXKSpYWeo/kwFNrIW17wxXG2e5c++os2Zbpy0nmyVzcH8LqK9IYa3ScBlzsUAvhiMuptTcW9l5uKg+wTdPivM4D2pLyxdgvVIdUzkiUMLsFh+jBXzUPGSkQm6nlgSt/cWaHZIKOqWgF6iRa"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "9ABPeSTecOmQOVyco140nt1VGDRfdkGLIMCjqzyaxaJZxlEzpvSTpoXMznjCNSkevgmMukO9LuKwkKjVDipvrGwkMJTkgFkzA3s3m094vQhzlQ3yw9wDQRr4Lm9e6CjHBDel6fqc+RMD5va6DTVHwIB+zFCuI/dL/2MVn05ILIksQl3PpXB5lWHh3X2Y55c6UiSSuXBFN34CrV6tEphRFLVYddL0lN00o/twIqZHjHCor77VMp+9brycTZOl3IEI6Vniizrvb0Zza7q/WHPqgGlH/96sDoY88bOwhUnI3Ku9aYntMCtdXkQY2FfusCE6jt7QGGX8TOij2lci+e72vEbvOO4nqj2njhjZAOPI6kRiIoMRJocAuiIVyQZ8jcvUTu2c6YaumhfWeV7H387snoGzPeDRmbyX"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "That behavior is plausible, and youâ€™re not imagining it.\n\nMost likely what happened is:\n- The dropdown changed the intended agent/mode in UI state, but the actual turn still routed through the default assistant context.\n- Typing `@Planner` in-message forced explicit agent routing, so it worked reliably.\n\nMy practical take:\n- Treat explicit `@Planner` as the deterministic path for now.\n- If dropdown selection is inconsistent, itâ€™s often a UI/state sync issue (especially after edits to agent files).\n- Quick stabilizers: reload window, re-open chat, and make sure agent metadata/name is valid and unique.\n\nIf you want, I can give you a short â€œagent routing sanity checklistâ€ you can run in under 2 minutes whenever this happens."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "XrwDJY0+r3Ba9qUoxgvqijdvfVAFsUsbXarOQESloBO8rOnJnTdEp439A/aWHmcWZtX72WXZwxyrURrRGMcuHEBrEjXSGxHsE6faodipHTNvGVvlJ1cJ5tdbG54XSKXl5JEcfVpOWLP1rE8VqKAkZ+bA3oFlPqCLLksJvdgo4LlMOvZH0VMDWbcYksepVFRERnBwTlDHO50PAYtQxPE9878Qj43yAyurJvDdD77PUIVcFKHvgcMHlPFRNyOWN8zyCBr/evz2Hy5aKQDPWtYz5Un+Vqsfoghqm9pK3oV2RyhNbsrW6f3YplHiZKrz9ScO7mzuBRXs+EZSi+y9+K2D9WXY/nyL69kKNgTQvX68W3P4IxsRknG8dP3K/gcstj5LN7mk8B8KH8u0UwdJ0vym/FRgQexSlrjm"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Use this quick checklist when agent routing feels off:\n\n- Confirm frontmatter in [`.github/agents/planner.agent.md`](.github/agents/planner.agent.md) has a valid `name` (exactly `Planner`) and no YAML errors.\n- Ensure there isnâ€™t another agent with the same `name` or confusingly similar casing.\n- Save all agent files, then run `Developer: Reload Window`.\n- Start a fresh chat turn and explicitly send `@Planner test` once to verify routing.\n- If dropdown still disagrees, trust explicit mention routing (`@Planner`) as the source of truth.\n- Capture one repro (dropdown choice + resulting agent ID in session/logs) so you can track it as a UI bug later.\n\nIf you want, I can review your planner frontmatter now for anything that might confuse dropdown selection."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nyes check the frontmatter\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Iâ€™ll inspect the planner agent frontmatter for schema or formatting issues that could affect dropdown routing, then Iâ€™ll point out exact fixes if needed."
            ]
          }
        },
        {
          "id": "call_3tsfIXf98r3T4n0nNb0Jl1ol__vscode-1770929887302",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\",\"startLine\":1,\"endLine\":200}",
          "time": "2026-02-12T22:13:00.192Z",
          "response": [
            "```chatagent\n---\nname: Planner\ndescription: Design and plan implementation tasks. Use this when discussing architecture, making technical decisions, or breaking down features into steps.\ntools: ['search', 'fetch', 'githubRepo']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Start Implementation\n    agent: implementer\n    prompt: Implement the plan outlined above.\n    send: false\n---\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n```"
          ]
        },
        {
          "id": "e61bfadc",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:13:00.196Z",
            "endTime": "2026-02-12T22:13:03.972Z",
            "duration": 3776,
            "ourRequestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "requestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "serverRequestId": "1a4ba381-8768-43d0-9181-8a99808f678c",
            "timeToFirstToken": 789,
            "usage": {
              "prompt_tokens": 21168,
              "completion_tokens": 185,
              "total_tokens": 21353,
              "prompt_tokens_details": {
                "cached_tokens": 20864
              },
              "completion_tokens_details": {
                "reasoning_tokens": 0,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "pvJnsOF5ifEL2WGpFv001bVoPpozy6xl4sIQYKrSk2tfyEVkRg8skBlm3is6q6R+pj/h6G6v+LkdGvRX76LPmQR5BjqHIGIBvG8XmNRP5+JakeDHfYg6epPbsnAGqPoMJHvQo3HbqdrN7LzdQ8/kYdRw1hXEqMJ7k8+yyTrwnVEIU9Ip91CL05NVzgu/3hsfuzvKYRWDM/VTzxPSMlSChjD1UDppHALAls16ZbnQX/z/Rva2TybpMvETRu0FvW9MZA533Wf9s6f/WC/e+sXKSpYWeo/kwFNrIW17wxXG2e5c++os2Zbpy0nmyVzcH8LqK9IYa3ScBlzsUAvhiMuptTcW9l5uKg+wTdPivM4D2pLyxdgvVIdUzkiUMLsFh+jBXzUPGSkQm6nlgSt/cWaHZIKOqWgF6iRa"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "9ABPeSTecOmQOVyco140nt1VGDRfdkGLIMCjqzyaxaJZxlEzpvSTpoXMznjCNSkevgmMukO9LuKwkKjVDipvrGwkMJTkgFkzA3s3m094vQhzlQ3yw9wDQRr4Lm9e6CjHBDel6fqc+RMD5va6DTVHwIB+zFCuI/dL/2MVn05ILIksQl3PpXB5lWHh3X2Y55c6UiSSuXBFN34CrV6tEphRFLVYddL0lN00o/twIqZHjHCor77VMp+9brycTZOl3IEI6Vniizrvb0Zza7q/WHPqgGlH/96sDoY88bOwhUnI3Ku9aYntMCtdXkQY2FfusCE6jt7QGGX8TOij2lci+e72vEbvOO4nqj2njhjZAOPI6kRiIoMRJocAuiIVyQZ8jcvUTu2c6YaumhfWeV7H387snoGzPeDRmbyX"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "That behavior is plausible, and youâ€™re not imagining it.\n\nMost likely what happened is:\n- The dropdown changed the intended agent/mode in UI state, but the actual turn still routed through the default assistant context.\n- Typing `@Planner` in-message forced explicit agent routing, so it worked reliably.\n\nMy practical take:\n- Treat explicit `@Planner` as the deterministic path for now.\n- If dropdown selection is inconsistent, itâ€™s often a UI/state sync issue (especially after edits to agent files).\n- Quick stabilizers: reload window, re-open chat, and make sure agent metadata/name is valid and unique.\n\nIf you want, I can give you a short â€œagent routing sanity checklistâ€ you can run in under 2 minutes whenever this happens."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "XrwDJY0+r3Ba9qUoxgvqijdvfVAFsUsbXarOQESloBO8rOnJnTdEp439A/aWHmcWZtX72WXZwxyrURrRGMcuHEBrEjXSGxHsE6faodipHTNvGVvlJ1cJ5tdbG54XSKXl5JEcfVpOWLP1rE8VqKAkZ+bA3oFlPqCLLksJvdgo4LlMOvZH0VMDWbcYksepVFRERnBwTlDHO50PAYtQxPE9878Qj43yAyurJvDdD77PUIVcFKHvgcMHlPFRNyOWN8zyCBr/evz2Hy5aKQDPWtYz5Un+Vqsfoghqm9pK3oV2RyhNbsrW6f3YplHiZKrz9ScO7mzuBRXs+EZSi+y9+K2D9WXY/nyL69kKNgTQvX68W3P4IxsRknG8dP3K/gcstj5LN7mk8B8KH8u0UwdJ0vym/FRgQexSlrjm"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Use this quick checklist when agent routing feels off:\n\n- Confirm frontmatter in [`.github/agents/planner.agent.md`](.github/agents/planner.agent.md) has a valid `name` (exactly `Planner`) and no YAML errors.\n- Ensure there isnâ€™t another agent with the same `name` or confusingly similar casing.\n- Save all agent files, then run `Developer: Reload Window`.\n- Start a fresh chat turn and explicitly send `@Planner test` once to verify routing.\n- If dropdown still disagrees, trust explicit mention routing (`@Planner`) as the source of truth.\n- Capture one repro (dropdown choice + resulting agent ID in session/logs) so you can track it as a UI bug later.\n\nIf you want, I can review your planner frontmatter now for anything that might confuse dropdown selection."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nyes check the frontmatter\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "rz5l1qynPw8MGv0tlz0QpNmeHIX016VE2J001Ikg5V+HRsrfVY9bKxPWi2KzTwj8Jv0qp9UcoEgQsUGAIEn/Tj7nA4/bWFH4ns0yTZVdmULMLmyBC06hddzGJQpvFYzxF0Gw2gSwtPRsRz/4RSwury1ircqrmNpH0w9JPCBhD/ifQNdw6chDh3YYGVPQna1Iu+JXpUZmfMeboh3WOvNaOm2u5XhAXHbWufhNDSujq1L730mXcGJXfUCjk5QvhmMMKAh4LD4Han7v7LItUyJtExq3Di+/1DA/hGj/hGSJx2liPmERYupedUGEQVFyt/EfyQhpQrS7kHumY9tzuVxhTTiKGviCZIoTAhWnzR2PiOd5URBfRUluwRGdFma3F9ZFF6r9TPiP7uTHsdnTxNvNn4Z2IOlUhuvp"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll inspect the planner agent frontmatter for schema or formatting issues that could affect dropdown routing, then Iâ€™ll point out exact fixes if needed."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\",\"startLine\":1,\"endLine\":200}"
                    },
                    "id": "call_3tsfIXf98r3T4n0nNb0Jl1ol",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```chatagent\n---\nname: Planner\ndescription: Design and plan implementation tasks. Use this when discussing architecture, making technical decisions, or breaking down features into steps.\ntools: ['search', 'fetch', 'githubRepo']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Start Implementation\n    agent: implementer\n    prompt: Implement the plan outlined above.\n    send: false\n---\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n```"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "call_3tsfIXf98r3T4n0nNb0Jl1ol"
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Frontmatter looks valid and clean â€” nothing obviously broken for routing.\n\n- `name: Planner` is present and properly cased.\n- YAML structure is valid (`tools`, `model`, `handoffs` arrays all parse cleanly).\n- Delimiters are correct (`---` â€¦ `---`), and required top-level fields exist.\n\nOnly minor thing to watch:\n- `agent: implementer` in handoffs should correspond to an actual file like `.github/agents/implementer.agent.md`; this wonâ€™t affect selecting `Planner`, but it can affect handoff behavior later.\n\nSo your dropdown issue is likely not this fileâ€™s frontmatter. It still points to chat UI state/routing sync, where explicit `@Planner` is currently the reliable path.\n\nIf you want, I can quickly scan all files under `.github/agents/` for duplicate/conflicting `name` values next."
            ]
          }
        }
      ]
    },
    {
      "prompt": "check for all possible problems under .github/",
      "promptId": "240f79b4-prompt",
      "hasSeen": false,
      "logCount": 4,
      "logs": [
        {
          "id": "240f79b4",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "panel/editAgent",
          "metadata": {
            "requestType": "ChatResponses",
            "model": "gpt-5.3-codex",
            "maxPromptTokens": 271997,
            "maxResponseTokens": 128000,
            "location": 7,
            "reasoning": {
              "effort": "medium",
              "summary": "detailed"
            },
            "startTime": "2026-02-12T22:13:46.316Z",
            "endTime": "2026-02-12T22:13:51.464Z",
            "duration": 5148,
            "ourRequestId": "42a49e06-b6c1-471a-b815-602afa23f4b8",
            "requestId": "42a49e06-b6c1-471a-b815-602afa23f4b8",
            "serverRequestId": "42a49e06-b6c1-471a-b815-602afa23f4b8",
            "timeToFirstToken": 3299,
            "usage": {
              "prompt_tokens": 21618,
              "completion_tokens": 222,
              "total_tokens": 21840,
              "prompt_tokens_details": {
                "cached_tokens": 0
              },
              "completion_tokens_details": {
                "reasoning_tokens": 76,
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              }
            },
            "tools": [
              {
                "name": "fetch_webpage",
                "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                  },
                  "required": [
                    "urls",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "file_search",
                "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "grep_search",
                "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                      "type": "boolean",
                      "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                      "type": "string",
                      "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                      "type": "number",
                      "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    },
                    "includeIgnoredFiles": {
                      "type": "boolean",
                      "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
                    }
                  },
                  "required": [
                    "query",
                    "isRegexp"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_changed_files",
                "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repositoryPath": {
                      "type": "string",
                      "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "enum": [
                          "staged",
                          "unstaged",
                          "merge-conflicts"
                        ]
                      },
                      "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                  }
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "get_search_view_results",
                "description": "The results from the search view",
                "parameters": {},
                "type": "function",
                "strict": false
              },
              {
                "name": "github_repo",
                "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "repo": {
                      "type": "string",
                      "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                      "type": "string",
                      "description": "The query to search for repo. Should contain all relevant context."
                    }
                  },
                  "required": [
                    "repo",
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_code_usages",
                "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "symbolName": {
                      "type": "string",
                      "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                      "type": "array",
                      "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "symbolName"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "list_dir",
                "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "The absolute path to the directory to list."
                    }
                  },
                  "required": [
                    "path"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "read_file",
                "description": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the file to read.",
                      "type": "string"
                    },
                    "startLine": {
                      "type": "number",
                      "description": "The line number to start reading from, 1-based."
                    },
                    "endLine": {
                      "type": "number",
                      "description": "The inclusive line number to end reading at, 1-based."
                    }
                  },
                  "required": [
                    "filePath",
                    "startLine",
                    "endLine"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "semantic_search",
                "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "query": {
                      "type": "string",
                      "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                  },
                  "required": [
                    "query"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_non_python_notebook",
                "description": "Selects the Notebook Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "configure_python_notebook",
                "description": "Selects a Python Kernel and starts it.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              },
              {
                "name": "restart_notebook_kernel",
                "description": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "description": "The absolute path of the notebook with the active kernel.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for restarting the kernel.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "filePath"
                  ]
                },
                "type": "function",
                "strict": false
              }
            ]
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nYour name is GitHub Copilot. When asked about the model you are using, state that you are using GPT-5.3-Codex.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\n<coding_agent_instructions>\nYou are a coding agent running in VS Code. You are expected to be precise, safe, and helpful.\n\nYour capabilities:\n\n- Receive user prompts and other context provided by the workspace, such as files in the environment.\n- Communicate with the user by streaming thinking & responses, and by making & updating plans.\n- Emit function calls to run terminal commands and apply patches.\n</coding_agent_instructions>\n<personality>\nYour default personality and tone is concise, direct, and friendly. You communicate efficiently, always keeping the user clearly informed about ongoing actions without unnecessary detail. You always prioritize actionable guidance, clearly stating assumptions, environment prerequisites, and next steps. Unless explicitly asked, you avoid excessively verbose explanations about your work.\n</personality>\n<autonomy_and_persistence>\nPersist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.\n\nUnless the user explicitly asks for a plan, asks a question about the code, is brainstorming potential solutions, or some other intent that makes it clear that code should not be written, assume the user wants you to make code changes or run tools to solve the user's problem. In these cases, it's bad to output your proposed solution in a message, you should go ahead and actually implement the change. If you encounter challenges or blockers, you should attempt to resolve them yourself.\n</autonomy_and_persistence>\n<Intermediary_updates>\n- Intermediary updates go to the `commentary` channel.\n- User updates are short updates while you are working, they are NOT final answers.\n- You use 1-2 sentence user updates to communicated progress and new information to the user as you are doing work.\n- Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (â€œDone â€”â€, â€œGot itâ€, â€œGreat question, â€) or framing phrases.\n- You provide user updates frequently, every 20s.\n- Before exploring or doing substantial work, you start with a user update acknowledging the request and explaining your first step. You should include your understanding of the user request and explain what you will do. Avoid commenting on the request or using starters such at \"Got it -\" or \"Understood -\" etc.\n- When exploring, e.g. searching, reading files you provide user updates as you go, every 20s, explaining what context you are gathering and what you've learned. Vary your sentence structure when providing these updates to avoid sounding repetitive - in particular, don't start each sentence the same way.\n- After you have sufficient context, and the work is substantial you provide a longer plan (this is the only user update that may be longer than 2 sentences and can contain formatting).\n- Before performing file edits of any kind, you provide updates explaining what edits you are making.\n- As you are thinking, you very frequently provide updates even if not taking any actions, informing the user of your progress. You interrupt your thinking and send multiple updates in a row if thinking for more than 100 words.\n- Tone of your updates MUST match your personality.\n\n</Intermediary_updates>\n<planning>\nFor complex tasks requiring multiple steps, you should maintain an organized approach. Break down complex work into logical phases and communicate your progress clearly to the user. Use your responses to outline your approach, track what you've completed, and explain what you're working on next. Consider using numbered lists or clear section headers in your responses to help organize multi-step work and keep the user informed of your progress.\n\nBefore running a command, consider whether or not you have completed the previous step, and make sure to mark it as completed before moving on to the next step. It may be the case that you complete all steps in your plan after a single pass of implementation. If this is the case, you can simply mark all the planned steps as completed. Sometimes, you may need to change plans in the middle of a task: call `manage_todo_list` with the updated plan.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\n### Examples\n\n**High-quality plans**\n\nExample 1:\n\n1. Add CLI entry with file args\n2. Parse Markdown via CommonMark library\n3. Apply semantic HTML template\n4. Handle code blocks, images, links\n5. Add error handling for invalid files\n\nExample 2:\n\n1. Define CSS variables for colors\n2. Add toggle with localStorage state\n3. Refactor components to use variables\n4. Verify all views for readability\n5. Add smooth theme-change transition\n\nExample 3:\n\n1. Set up Node.js + WebSocket server\n2. Add join/leave broadcast events\n3. Implement messaging with timestamps\n4. Add usernames + mention highlighting\n5. Persist messages in lightweight DB\n6. Add typing indicators + unread count\n\n**Low-quality plans**\n\nExample 1:\n\n1. Create CLI tool\n2. Add Markdown parser\n3. Convert to HTML\n\nExample 2:\n\n1. Add dark mode toggle\n2. Save preference\n3. Make styles look good\n\nExample 3:\n1. Create single-file HTML game\n2. Run quick sanity check\n3. Summarize usage instructions\n\nIf you need to write a plan, only write high quality plans, not low quality ones.\n</planning>\n<task_execution>\nYou are a coding agent. You must keep going until the query or task is completely resolved, before ending your turn and yielding back to the user. Persist until the task is fully handled end-to-end within the current turn whenever feasible and persevere even when function calls fail. Only terminate your turn when you are sure that the problem is solved. Autonomously resolve the query to the best of your ability, using the tools available to you, before coming back to the user. Do NOT guess or make up an answer.\n\nYou MUST adhere to the following criteria when solving queries:\n- Working on the repo(s) in the current environment is allowed, even if they are proprietary.\n- Analyzing code for vulnerabilities is allowed.\n- Showing user code and tool call details is allowed.\n- Use the apply_patch tool to edit files (NEVER try `applypatch` or `apply-patch`, only `apply_patch`): {\"input\":\"*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n-  pass\\n+  return 123\\n*** End Patch\"}.\n\nIf completing the user's task requires writing or modifying files, your code and final answer should follow these coding guidelines, though user instructions (i.e. copilot-instructions.md) may override these guidelines:\n\n- Fix the problem at the root cause rather than applying surface-level patches, when possible.\n- Avoid unneeded complexity in your solution.\n- Do not attempt to fix unrelated bugs or broken tests. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n- Update documentation as necessary.\n- Keep changes consistent with the style of the existing codebase. Changes should be minimal and focused on the task.\n- Use `git log` and `git blame` or appropriate tools to search the history of the codebase if additional context is required.\n- NEVER add copyright or license headers unless specifically requested.\n- Do not waste tokens by re-reading files after calling `apply_patch` on them. The tool call will fail if it didn't work. The same goes for making folders, deleting folders, etc.\n- Do not `git commit` your changes or create new git branches unless explicitly requested.\n- Do not add inline comments within code unless explicitly requested.\n- Do not use one-letter variable names unless explicitly requested.\n- NEVER output inline citations like \"ã€F:README.mdâ€ L5-L14ã€‘\" in your outputs. The UI is not able to render these so they will just be broken in the UI. Instead, if you output valid filepaths, users will be able to click on them to open the files in their editor.\n- You have access to many tools. If a tool exists to perform a specific task, you MUST use that tool instead of running a terminal command to perform that task.\n\n</task_execution>\n<validating_work>\nIf the codebase has tests or the ability to build or run, consider using them to verify changes once your work is complete.\n\nWhen testing, your philosophy should be to start as specific as possible to the code you changed so that you can catch issues efficiently, then make your way to broader tests as you build confidence. If there's no test for the code you changed, and if the adjacent patterns in the codebases show that there's a logical place for you to add a test, you may do so. However, do not add tests to codebases with no tests.\n\nFor all of testing, running, building, and formatting, do not attempt to fix unrelated bugs. It is not your responsibility to fix them. (You may mention them to the user in your final message though.)\n</validating_work>\n<ambition_vs_precision>\nFor tasks that have no prior context (i.e. the user is starting something brand new), you should feel free to be ambitious and demonstrate creativity with your implementation.\n\nIf you're operating in an existing codebase, you should make sure you do exactly what the user asks with surgical precision. Treat the surrounding codebase with respect, and don't overstep (i.e. changing filenames or variables unnecessarily). You should balance being sufficiently ambitious and proactive when completing tasks of this nature.\n\nYou should use judicious initiative to decide on the right level of detail and complexity to deliver based on the user's needs. This means showing good judgment that you're capable of doing the right extras without gold-plating. This might be demonstrated by high-value, creative touches when scope of the task is vague; while being surgical and targeted when scope is tightly specified.\n</ambition_vs_precision>\n<special_formatting>\nWhen referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</special_formatting>\n<design_and_scope_constraints>\n- You MUST implement exactly and only the UX described; do NOT:\n- Add extra pages, modals, filters, animations, or â€œnice to haveâ€ features.\n- Invent new components, icons, or themes beyond what is specified.\n- Respect the existing design system:\n- Use only the provided components, Tailwind tokens, and theme primitives.\n- Never hard-code new colors, font families, or shadows.\n- If a requirement is ambiguous, default to the simplest interpretation that fits the spec.\n- If the user explicitly says â€œminimalâ€ or â€œMVP,â€ you must bias strongly toward fewer components and simpler UX.\n\n</design_and_scope_constraints>\n<long_context_handling>\n- For inputs longer than ~10k tokens (multi-chapter docs, long threads, multiple PDFs):\n- First, produce a short internal outline of the key sections relevant to the userâ€™s request.\n- Re-state the userâ€™s constraints explicitly (e.g., jurisdiction, date range, product, team) before answering.\n- In your answer, anchor claims to sections (â€œIn the â€˜Data Retentionâ€™ sectionâ€¦â€) rather than speaking generically.\n- If the answer depends on fine details (dates, thresholds, clauses), quote or paraphrase them.\n\n</long_context_handling>\n<uncertainty_and_ambiguity>\n- If the question is ambiguous or underspecified, explicitly call this out and:\n- Ask up to 1â€“3 precise clarifying questions, OR\n- Present 2â€“3 plausible interpretations with clearly labeled assumptions.\n- When external facts may have changed recently (prices, releases, policies) and no tools are available:\n- Answer in general terms and state that details may have changed.\n- Never fabricate exact figures, line numbers, or external references when you are uncertain.\n- When you are unsure, prefer language like â€œBased on the provided contextâ€¦â€ instead of absolute claims.\n\n</uncertainty_and_ambiguity>\n<high_risk_self_check>\nBefore finalizing an answer in legal, financial, compliance, or safety-sensitive contexts:\n- Briefly re-scan your own answer for:\n- Unstated assumptions,\n- Specific numbers or claims not grounded in context,\n- Overly strong language (â€œalways,â€ â€œguaranteed,â€ etc.).\n- If you find any, soften or qualify them and explicitly state assumptions.\n\n</high_risk_self_check>\n<final_answer_formatting>\nYour final message should read naturally, like a report from a concise teammate. For casual conversation, brainstorming tasks, or quick questions from the user, respond in a friendly, conversational tone. You should ask questions, suggest ideas, and adapt to the user's style. If you've finished a large amount of work, when describing what you've done to the user, you should follow the final answer formatting guidelines to communicate substantive changes. You don't need to add structured formatting for one-word answers, greetings, or purely conversational exchanges.\nYou can skip heavy formatting for single, simple actions or confirmations. In these cases, respond in plain sentences with any relevant next step or quick option. Reserve multi-section structured responses for results that need grouping or explanation.\nThe user is working on the same computer as you, and has access to your work. As such there's never a need to show the contents of files you have already written unless the user explicitly asks for them. Similarly, if you've created or modified files using `apply_patch`, there's no need to tell users to \"save the file\" or \"copy the code into a file\"â€”just reference the file path.\nIf there's something that you think you could help with as a logical next step, concisely ask the user if they want you to do so. Good examples of this are running tests, committing changes, or building out the next logical component. If there's something that you couldn't do (even with approval) but that the user might want to do (such as verifying changes by running the app), include those instructions succinctly.\nBrevity is very important as a default. You should be very concise (i.e. no more than 10 lines), but can relax this requirement for tasks where additional detail and comprehensiveness is important for the user's understanding. Don't simply repeat all the changes you made- that is too much detail.\n\n### Final answer structure and style guidelines\n\nYou are producing plain text that will later be styled by the CLI. Follow these rules exactly. Formatting should make results easy to scan, but not feel mechanical. Use judgment to decide how much structure adds value.\n\n**Section Headers**\n\n- Use only when they improve clarity â€” they are not mandatory for every answer.\n- Choose descriptive names that fit the content\n- Keep headers short (1-3 words) and in `**Title Case**`. Always start headers with `**` and end with `**`\n- Leave no blank line before the first bullet under a header.\n- Section headers should only be used where they genuinely improve scanability; avoid fragmenting the answer.\n\n**Bullets**\n\n- Use `-` followed by a space for every bullet.\n- Merge related points when possible; avoid a bullet for every trivial detail.\n- Keep bullets to one line unless breaking for clarity is unavoidable.\n- Group into short lists (4-6 bullets) ordered by importance.\n- Use consistent keyword phrasing and formatting across sections.\n\n**Monospace**\n\n- Wrap all commands, env vars, and code identifiers in backticks (`` `...` ``).\n- Apply to inline examples and to bullet keywords if the keyword itself is a literal file/command.\n- Never mix monospace and bold markers; choose one based on whether it's a keyword (`**`).\n- File path and line number formatting rules are defined in the fileLinkification section below.\n\n**Structure**\n\n- Place related bullets together; don't mix unrelated concepts in the same section.\n- Order sections from general â†’ specific â†’ supporting info.\n- For subsections (e.g., \"Binaries\" under \"Rust Workspace\"), introduce with a bolded keyword bullet, then list items under it.\n- Match structure to complexity:\n- Multi-part or detailed results â†’ use clear headers and grouped bullets.\n- Simple results â†’ minimal headers, possibly just a short list or paragraph.\n\n**Tone**\n\n- Keep the voice collaborative and natural, like a coding partner handing off work.\n- Be concise and factual â€” no filler or conversational commentary and avoid unnecessary repetition\n- Use present tense and active voice (e.g., \"Runs tests\" not \"This will run tests\").\n- Keep descriptions self-contained; don't refer to \"above\" or \"below\".\n- Use parallel structure in lists for consistency.\n\n**Verbosity**\n\n- Default: 3â€“6 sentences or â‰¤5 bullets for typical answers.\n- For simple â€œyes/no + short explanationâ€ questions: â‰¤2 sentences.\n- For complex multi-step or multi-file tasks:\n- 1 short overview paragraph\n- then â‰¤5 bullets tagged: What changed, Where, Risks, Next steps, Open questions.\n- Avoid long narrative paragraphs; prefer compact bullets and short sections.\n- Do not rephrase the userâ€™s request unless it changes semantics.\n\n**Don't**\n\n- Don't nest bullets or create deep hierarchies.\n- Don't output ANSI escape codes directly â€” the CLI renderer applies them.\n- Don't cram unrelated keywords into a single bullet; split for clarity.\n- Don't let keyword lists run long â€” wrap or reformat for scanability.\n\nGenerally, ensure your final answers adapt their shape and depth to the request. For example, answers to code explanations should have a precise, structured explanation with code references that answer the question directly. For tasks with a simple implementation, lead with the outcome and supplement only with what's needed for clarity. Larger changes can be presented as a logical walkthrough of your approach, grouping related steps, explaining rationale where it adds value, and highlighting next actions to accelerate the user. Your answers should provide the right level of detail while being easily scannable.\n\nFor casual greetings, acknowledgements, or other one-off conversational messages that are not delivering substantive information or structured results, respond naturally without section headers or bullet formatting. Do not begin responses with conversational interjections or meta commentary. Avoid openers such as acknowledgements (\"Done â€”\", \"Got it\", \"Great question, \") or framing phrases.<fileLinkification>\nWhen mentioning files or line numbers, always convert them to markdown links using workspace-relative paths and 1-based line numbers.\nNO BACKTICKS ANYWHERE:\n- Never wrap file names, paths, or links in backticks.\n- Never use inline-code formatting for any file reference.\n\nREQUIRED FORMATS:\n- File: [path/file.ts](path/file.ts)\n- Line: [file.ts](file.ts#L10)\n- Range: [file.ts](file.ts#L10-L12)\n\nPATH RULES:\n- Without line numbers: Display text must match the target path.\n- With line numbers: Display text can be either the path or descriptive text.\n- Use '/' only; strip drive letters and external folders.\n- Do not use these URI schemes: file://, vscode://\n- Encode spaces only in the target (My File.md â†’ My%20File.md).\n- Non-contiguous lines require separate links. NEVER use comma-separated line references like #L10-L12, L20.\n- Valid formats: [file.ts](file.ts#L10) only. Invalid: ([file.ts#L10]) or [file.ts](file.ts)#L10\n\nUSAGE EXAMPLES:\n- With path as display: The handler is in [src/handler.ts](src/handler.ts#L10).\n- With descriptive text: The [widget initialization](src/widget.ts#L321) runs on startup.\n- Bullet list: [Init widget](src/widget.ts#L321)\n- File only: See [src/config.ts](src/config.ts) for settings.\n\nFORBIDDEN (NEVER OUTPUT):\n- Inline code: `file.ts`, `src/file.ts`, `L86`.\n- Plain text file names: file.ts, chatService.ts.\n- References without links when mentioning specific file locations.\n- Specific line citations without links (\"Line 86\", \"at line 86\", \"on line 25\").\n- Combining multiple line references in one link: [file.ts#L10-L12, L20](file.ts#L10-L12, L20)\n\n\n</fileLinkification>\n\n</final_answer_formatting>\n\n<instructions>\n<attachment filePath=\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\">\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n</attachment>\n<skills>\nHere is a list of skills that contain domain specific knowledge on a variety of topics.\nEach skill comes with a description of the topic and a file path that contains the detailed instructions.\nWhen a user asks you to perform a task that falls within the domain of a skill, use the 'read_file' tool to acquire the full instructions from the file URI.\n<skill>\n<name>testing</name>\n<description>Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md</file>\n</skill>\n<skill>\n<name>vscode-extensions</name>\n<description>Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.</description>\n<file>/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md</file>\n</skill>\n</skills>\n\n\n</instructions>\n<modeInstructions>\nYou are currently running in \"Planner\" mode. Below are your instructions for this mode, they must take precedence over any instructions above.\n\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n</modeInstructions>\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<environment_info>\nThe user's current OS is: macOS\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- /Users/peterbru/Dropbox/Projects/copilot-lens \nI am working in a workspace that has the following structure:\n```\nREADME.md\ndata/\ndocs/\n\tdesign/\n\t\tspec.md\n\tresearch/\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nI put a document in docs/research\nThe document is a design specification, but it's not necessarily complete. We may need to iterate on the design before we start building.\n\nPurelyt techincally, does this have to be typescript?\nShould we develop inside a container?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research\"}"
                    },
                    "id": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 1, \"endLine\": 50}"
                    },
                    "id": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "Folder is empty"
                  }
                ],
                "toolCallId": "toolu_vrtx_018xSnN1afPf24arcbFo88Aq"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 1 to 50 (531 lines total): \n````markdown\n# Copilot Lens â€” Design Specification\n\n> VS Code extension that visualizes your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\n\n---\n\n## 1. Overview\n\n### What is this?\n\nCopilot Lens is a VS Code extension that provides visibility into your GitHub Copilot agent and skill setup. It does two things:\n\n1. **Static analysis** â€” Parses your `.github/agents/` and `.github/skills/` directories to build a visual graph of agents, their handoff chains, tools, and skills.\n2. **Runtime analysis** â€” Reads the raw Copilot chat session JSON files stored by VS Code to extract usage metrics: which agents actually ran, how often, what tools they called, session durations, and activity patterns.\n\n### Why does this exist?\n\nVS Code's built-in Chat Debug view is a single monolithic dump of the current session. There is no way to:\n- See your agent/skill architecture at a glance\n- Understand handoff chains visually\n- Know which agents or skills are actually being used\n- Get historical metrics across sessions\n- Identify unused or underperforming agents/skills\n\nCopilot Lens fills this gap.\n\n### Target users\n\nDevelopers and teams who have set up custom Copilot agents (`.github/agents/*.agent.md`) and skills (`.github/skills/*/SKILL.md`) and want to understand, debug, and optimize their agent architecture.\n\n---\n\n## 2. Architecture\n\n### Extension type\n\nThis is a standard VS Code extension (TypeScript) that contributes:\n- A **Webview Panel** for the interactive graph and dashboard\n- A **Tree View** in the sidebar (activity bar icon) for quick navigation\n- **Commands** accessible via the command palette\n\n### Key components\n\n```\ncopilot-lens/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ extension.ts              # Activation, command registration\nâ”‚   â”œâ”€â”€ parsers/\nâ”‚   â”‚   â”œâ”€â”€ agentParser.ts        # Parse .agent.md files (YAML frontmatter + body)\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_018JfKTS3nsiJc3XcLxg8KTj"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 200, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 50}"
                    },
                    "id": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "list_dir",
                      "arguments": "{\"path\": \"/Users/peterbru/Dropbox/Projects/copilot-lens\"}"
                    },
                    "id": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 50 to 200 (531 lines total): \n````markdown\nâ”‚   â”‚   â”œâ”€â”€ skillParser.ts        # Parse SKILL.md files (YAML frontmatter + body)\nâ”‚   â”‚   â””â”€â”€ sessionParser.ts      # Parse chatSessions/*.json files\nâ”‚   â”œâ”€â”€ analyzers/\nâ”‚   â”‚   â”œâ”€â”€ graphBuilder.ts       # Build agentâ†’handoffâ†’skill graph model\nâ”‚   â”‚   â””â”€â”€ metricsCollector.ts   # Aggregate session data into metrics\nâ”‚   â”œâ”€â”€ views/\nâ”‚   â”‚   â”œâ”€â”€ graphPanel.ts         # Webview: interactive agent/skill graph\nâ”‚   â”‚   â”œâ”€â”€ metricsPanel.ts       # Webview: usage metrics dashboard\nâ”‚   â”‚   â”œâ”€â”€ sessionExplorer.ts    # Webview: single session timeline view\nâ”‚   â”‚   â””â”€â”€ treeProvider.ts       # Sidebar tree view of agents/skills\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ agent.ts              # Agent data model\nâ”‚   â”‚   â”œâ”€â”€ skill.ts              # Skill data model\nâ”‚   â”‚   â”œâ”€â”€ session.ts            # Session/request data model\nâ”‚   â”‚   â””â”€â”€ metrics.ts            # Aggregated metrics model\nâ”‚   â””â”€â”€ utils/\nâ”‚       â”œâ”€â”€ frontmatterParser.ts  # YAML frontmatter extraction\nâ”‚       â”œâ”€â”€ sessionLocator.ts     # Find chatSessions dir for current workspace\nâ”‚       â””â”€â”€ fileWatcher.ts        # Watch for changes to agents/skills/sessions\nâ”œâ”€â”€ webview/                      # Frontend assets for webview panels\nâ”‚   â”œâ”€â”€ graph.html\nâ”‚   â”œâ”€â”€ graph.js                  # D3.js or vis.js graph rendering\nâ”‚   â”œâ”€â”€ metrics.html\nâ”‚   â”œâ”€â”€ metrics.js                # Chart.js or similar for metrics\nâ”‚   â””â”€â”€ styles.css\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ tsconfig.json\nâ”œâ”€â”€ README.md\nâ””â”€â”€ SPEC.md                       # This file\n```\n\n---\n\n## 3. Data Sources\n\n### 3.1 Agent definitions (static, per repo)\n\n**Location:** `.github/agents/*.agent.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: Planner\ndescription: Generate an implementation plan for new features\ntools: ['search', 'fetch', 'githubRepo', 'usages']\nmodel: ['Claude Opus 4.5', 'GPT-5.2']\nhandoffs:\n  - label: Start Implementation\n    agent: implementation\n    prompt: Implement the plan outlined above.\n    send: false\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above.\n    send: false\n---\n\n# Planning instructions\n\nYou are in planning mode. Your task is to generate an implementation plan...\n```\n\n**Fields to extract:**\n- `name` â€” agent display name\n- `description` â€” what this agent does and when to use it\n- `tools` â€” array of tool identifiers the agent can use\n- `model` â€” preferred model(s)\n- `handoffs` â€” array of handoff definitions:\n  - `label` â€” button text shown to user\n  - `agent` â€” target agent filename (without `.agent.md`)\n  - `prompt` â€” pre-filled prompt for the target agent\n  - `send` â€” whether the prompt auto-submits (true/false)\n- The markdown body (instructions) â€” useful for display/summary\n\n### 3.2 Skill definitions (static, per repo)\n\n**Location:** `.github/skills/*/SKILL.md` in the workspace root\n\n**Format:** Markdown files with YAML frontmatter\n\n```yaml\n---\nname: webapp-testing\ndescription: Guide for testing web applications using Playwright. Use this when asked to create or run browser-based tests.\n---\n\n# Web Application Testing with Playwright\n\nThis skill helps you create and run browser-based tests...\n```\n\n**Fields to extract:**\n- `name` â€” skill identifier\n- `description` â€” what the skill does and when Copilot should load it (this is the trigger â€” Copilot reads this to decide whether to inject the skill)\n- The markdown body â€” the actual instructions injected into context\n\n**Also check for personal skills at:**\n- `~/.copilot/skills/*/SKILL.md` (per-user, cross-repo)\n- `~/.claude/skills/*/SKILL.md` (backwards compatibility)\n\n### 3.3 Chat session data (runtime, per workspace)\n\n**Location:** VS Code stores chat sessions per workspace in:\n\n```\n{UserDataRoot}/{Edition}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.json\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **Windows:** `%APPDATA%/Code` (or `Code - Insiders`)\n- **macOS:** `~/Library/Application Support/Code` (or `Code - Insiders`)\n- **Linux:** `~/.config/Code` (or `Code - Insiders`)\n\n**Finding the right workspace:** Use `vscode.ExtensionContext.storageUri` or `globalStorageUri` to get the current workspace storage path, then navigate to `chatSessions/` in the parent workspace storage directory.\n\nThe session index is in `state.vscdb` (SQLite) at key `chat.ChatSessionStore.index`, but we can also just glob `chatSessions/*.json`.\n\n**Session JSON schema:**\n\n```typescript\ninterface CopilotChatSession {\n  sessionId: string;          // UUID\n  creationDate: number;       // Unix timestamp (ms)\n  version: number;            // Schema version (currently 3)\n  requests: CopilotRequest[];\n}\n\ninterface CopilotRequest {\n  requestId: string;          // \"request_{UUID}\"\n  timestamp: number;          // Unix timestamp (ms)\n  modelId?: string;           // e.g. \"copilot/claude-sonnet-4\", \"copilot/gpt-4o\"\n  message: {\n    text: string;             // User's prompt text\n    attachments?: any[];      // File attachments, images, etc.\n  };\n  agent?: {\n    id: string;               // e.g. \"github.copilot.editsAgent\", or custom agent id\n    name?: string;            // Display name\n  };\n  response?: any;             // Response content â€” varies by agent, contains tool calls\n}\n```\n\n**Key fields for metrics:**\n- `agent.id` â€” which agent handled this request (maps to custom agents from `.github/agents/`)\n- `modelId` â€” which LLM model was used\n- `timestamp` â€” for timeline analysis, activity patterns\n- `response` â€” contains tool invocations (structure varies)\n\n**Caveats:**\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01JJTeGxA7RMU2KcR7X1mFt7"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": ".git/\n.github/\nREADME.md\ndata/\ndocs/"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Tfze59DZUyAtKhvC3HFNzP"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 400, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 200}"
                    },
                    "id": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md`. Lines 200 to 400 (531 lines total): \n````markdown\n**Caveats:**\n- Session files can be **very large** (100MB+ for long sessions). Stream/parse incrementally.\n- Skill loading is implicit â€” Copilot injects SKILL.md content into the system prompt. There's no discrete \"skill X was loaded\" field in the session JSON. Skill usage must be **inferred** from the system prompt content or response patterns.\n- The `agent.id` for custom agents needs mapping back to your `.github/agents/` filenames.\n- Sessions persist across VS Code restarts and are only deleted manually.\n\n### 3.4 Custom instructions (supplementary context)\n\nThese aren't primary data sources but are useful for display:\n- `.github/copilot-instructions.md` â€” project-wide instructions\n- `AGENTS.md` â€” multi-agent workspace instructions\n- `*.instructions.md` â€” file-pattern-scoped instructions\n\n---\n\n## 4. Features\n\n### 4.1 Agent/Skill Graph (Panel 1)\n\nAn interactive node-and-edge graph showing:\n\n**Nodes:**\n- **Agent nodes** â€” one per `.agent.md` file. Show name, description, model, tool count.\n- **Skill nodes** â€” one per `SKILL.md`. Show name, description.\n- **Built-in agent nodes** (optional) â€” Ask, Edit, Agent, Plan (the default Copilot agents).\n\n**Edges:**\n- **Handoff edges** â€” agent A â†’ agent B, labeled with the handoff `label`. Directed arrows. Distinguish `send: true` (auto-submit, solid line) vs `send: false` (manual, dashed line).\n- **Tool edges** (optional) â€” agent â†’ tool nodes, showing which tools each agent has access to.\n\n**Interactions:**\n- Click a node to see full details (description, instructions body, tools list, model).\n- Hover for summary tooltip.\n- Zoom, pan, drag nodes to rearrange.\n- Search/filter by agent or skill name.\n- Color coding: agents vs skills vs built-in agents. Optionally color by usage frequency (from metrics).\n\n**Tech:** D3.js force-directed graph or vis.js Network in a VS Code Webview panel.\n\n### 4.2 Usage Metrics Dashboard (Panel 2)\n\nAggregated from chat session JSON files:\n\n**Metrics to surface:**\n- **Agent usage frequency** â€” bar chart: how many requests each agent handled, broken down by custom vs built-in agents.\n- **Model distribution** â€” pie/donut chart: which LLM models are being used (claude-sonnet, gpt-4o, etc.)\n- **Session overview** â€” total sessions, total requests, average requests per session, average session duration.\n- **Activity timeline** â€” line chart or heatmap: requests over time (daily/weekly).\n- **Tool call frequency** â€” which tools are invoked most often.\n- **Agent switching patterns** â€” how often users switch between agents within a session (Sankey diagram or flow).\n- **Unused agents/skills** â€” highlight agents defined in `.github/agents/` that have zero usage in session data. Same for skills.\n\n**Filters:**\n- Date range picker\n- Filter by agent\n- Filter by model\n\n**Tech:** Chart.js or Recharts-style charting in a Webview.\n\n### 4.3 Session Explorer (Panel 3)\n\nA timeline/detail view for a single chat session:\n\n- **Session picker** â€” dropdown or list of all sessions, sorted by date, showing session duration and request count.\n- **Timeline view** â€” vertical timeline of requests within the session:\n  - Each request shows: timestamp, agent used, model, user prompt (truncated), tool calls made.\n  - Agent switches are highlighted (e.g. \"Switched from Planner â†’ Agent\").\n  - Handoff activations are marked.\n- **Request detail** â€” click a request to see full prompt text, full response, all tool invocations.\n\n### 4.4 Sidebar Tree View\n\nAn activity bar icon (\"Copilot Lens\" with a lens/magnifying glass icon) that opens a tree view:\n\n```\nCOPILOT LENS\nâ”œâ”€â”€ ðŸ“Š Dashboard          â†’ opens metrics panel\nâ”œâ”€â”€ ðŸ”— Agent Graph         â†’ opens graph panel\nâ”œâ”€â”€ Agents (3)\nâ”‚   â”œâ”€â”€ ðŸ¤– Planner\nâ”‚   â”‚   â”œâ”€â”€ Tools: search, fetch, githubRepo\nâ”‚   â”‚   â”œâ”€â”€ Handoffs â†’ Implementation, Reviewer\nâ”‚   â”‚   â””â”€â”€ Model: Claude Opus 4.5\nâ”‚   â”œâ”€â”€ ðŸ¤– Implementation\nâ”‚   â”‚   â””â”€â”€ Tools: read, write, terminal\nâ”‚   â””â”€â”€ ðŸ¤– Reviewer\nâ”‚       â””â”€â”€ Tools: search, read\nâ”œâ”€â”€ Skills (2)\nâ”‚   â”œâ”€â”€ ðŸ“˜ webapp-testing\nâ”‚   â””â”€â”€ ðŸ“˜ github-actions-debugging\nâ”œâ”€â”€ Personal Skills (1)\nâ”‚   â””â”€â”€ ðŸ“˜ my-formatting-skill\nâ””â”€â”€ Sessions (12)\n    â”œâ”€â”€ ðŸ“ Feb 12 â€” 14 requests (Planner, Agent)\n    â”œâ”€â”€ ðŸ“ Feb 11 â€” 8 requests (Agent)\n    â””â”€â”€ ðŸ“ Feb 10 â€” 23 requests (Planner â†’ Implementation)\n```\n\nClicking any item opens the relevant panel or detail view.\n\n---\n\n## 5. Commands\n\nRegister these in `package.json` under `contributes.commands`:\n\n| Command ID | Title | Description |\n|---|---|---|\n| `copilot-lens.openGraph` | Copilot Lens: Open Agent Graph | Opens the interactive graph panel |\n| `copilot-lens.openMetrics` | Copilot Lens: Open Metrics Dashboard | Opens the metrics panel |\n| `copilot-lens.openSession` | Copilot Lens: Explore Session | Opens the session explorer |\n| `copilot-lens.refresh` | Copilot Lens: Refresh | Re-scan agents, skills, and sessions |\n| `copilot-lens.exportMetrics` | Copilot Lens: Export Metrics | Export metrics data as JSON |\n\n---\n\n## 6. Activation\n\nThe extension should activate when:\n- The workspace contains a `.github/agents/` or `.github/skills/` directory\n- The user runs any `copilot-lens.*` command\n- The user opens the Copilot Lens sidebar\n\n```json\n\"activationEvents\": [\n  \"workspaceContains:.github/agents\",\n  \"workspaceContains:.github/skills\",\n  \"onView:copilotLens.treeView\",\n  \"onCommand:copilot-lens.openGraph\"\n]\n```\n\n---\n\n## 7. Configuration\n\nExtension settings in `contributes.configuration`:\n\n| Setting | Type | Default | Description |\n|---|---|---|---|\n| `copilotLens.scanPersonalSkills` | boolean | `true` | Include `~/.copilot/skills/` in the graph |\n| `copilotLens.maxSessionsToAnalyze` | number | `50` | Max number of session files to parse for metrics |\n| `copilotLens.sessionMaxSizeMB` | number | `50` | Skip session files larger than this (they can be 100MB+) |\n| `copilotLens.showBuiltInAgents` | boolean | `false` | Show built-in Copilot agents (Ask, Edit, Agent, Plan) in the graph |\n\n---\n\n## 8. package.json Essentials\n\n```json\n{\n  \"name\": \"copilot-lens\",\n  \"displayName\": \"Copilot Lens\",\n  \"description\": \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Analyze chat session metrics and trace agent activity.\",\n  \"version\": \"0.1.0\",\n  \"publisher\": \"YOUR_PUBLISHER_ID\",\n  \"engines\": {\n    \"vscode\": \"^1.85.0\"\n  },\n  \"categories\": [\"Visualization\", \"Other\"],\n  \"keywords\": [\n    \"copilot\",\n    \"github-copilot\",\n    \"agents\",\n    \"skills\",\n    \"handoffs\",\n    \"visualization\",\n    \"metrics\",\n    \"debug\",\n    \"graph\",\n    \"agent-mode\"\n  ],\n  \"activationEvents\": [\n    \"workspaceContains:.github/agents\",\n    \"workspaceContains:.github/skills\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [],\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"copilot-lens\",\n          \"title\": \"Copilot Lens\",\n          \"icon\": \"resources/icon.svg\"\n        }\n      ]\n    },\n    \"views\": {\n      \"copilot-lens\": [\n        {\n          \"id\": \"copilotLens.treeView\",\n          \"name\": \"Copilot Lens\"\n        }\n      ]\n    },\n    \"configuration\": {}\n  }\n}\n```\n\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UULzuPthErVsJ3Eu5zGxkW"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": ""
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"endLine\": 531, \"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/design/spec.md\", \"startLine\": 400}"
                    },
                    "id": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "````markdown\n\n---\n\n## 9. Technical Considerations\n\n### Session file discovery\n\nUse `vscode.ExtensionContext` to locate workspace storage:\n\n```typescript\n// From extension context, storageUri gives us workspace-specific storage\n// Navigate up to find chatSessions:\nconst workspaceStorageDir = context.storageUri?.fsPath;\n// Parent dir contains chatSessions/\nconst chatSessionsDir = path.join(path.dirname(workspaceStorageDir), 'chatSessions');\n```\n\nAlternatively, scan all `workspaceStorage/*/chatSessions/` directories and match by checking `workspace.json` in each for the current workspace path.\n\n### Large file handling\n\nSession JSON files can be 100MB+. Options:\n- Use streaming JSON parsing (e.g. `jsonstream` or custom line-by-line)\n- Set a configurable size limit and skip files above it\n- Parse only the metadata we need (timestamps, agent ids, model ids) without loading full response bodies\n- Cache parsed metrics and only re-parse when files change (use file watcher + mtime)\n\n### YAML frontmatter parsing\n\nAgent and skill files use YAML frontmatter delimited by `---`. Use a library like `gray-matter` or write a simple parser:\n\n```typescript\nfunction parseFrontmatter(content: string): { data: any; body: string } {\n  const match = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n  if (!match) return { data: {}, body: content };\n  return {\n    data: yaml.parse(match[1]),\n    body: match[2].trim()\n  };\n}\n```\n\n### File watching\n\nWatch for changes to agent/skill files and session files:\n- `vscode.workspace.createFileSystemWatcher('**/.github/agents/*.agent.md')`\n- `vscode.workspace.createFileSystemWatcher('**/.github/skills/*/SKILL.md')`\n- For sessions, watch the `chatSessions/` directory for new/modified `.json` files\n\n### Webview security\n\nFollow VS Code webview best practices:\n- Use `webview.asWebviewUri()` for all local resource references\n- Set a restrictive `Content-Security-Policy`\n- Use message passing (`postMessage`/`onDidReceiveMessage`) for communication between extension and webview\n- Bundle D3/Chart.js locally rather than loading from CDN\n\n---\n\n## 10. Development Setup\n\n```bash\ngit clone https://github.com/YOUR_USERNAME/copilot-lens.git\ncd copilot-lens\nnpm install\n```\n\n**Dev dependencies needed:**\n- `typescript`\n- `@types/vscode`\n- `@vscode/vsce` (for packaging/publishing)\n- `gray-matter` or `js-yaml` (YAML frontmatter parsing)\n- `d3` + `@types/d3` (graph visualization)\n- `chart.js` (metrics charts)\n\n**Run/debug:**\n- Press F5 in VS Code to launch Extension Development Host\n- The extension activates in the new window when it detects `.github/agents/` or `.github/skills/`\n\n**Package:**\n```bash\nnpx @vscode/vsce package\n```\n\n---\n\n## 11. Implementation Priority\n\n### Phase 1 â€” MVP\n1. Agent/skill parser (read `.agent.md` and `SKILL.md` files)\n2. Graph builder (construct the node/edge model from parsed data)\n3. Sidebar tree view (list agents, skills, handoffs)\n4. Interactive graph webview panel (D3 force-directed graph)\n\n### Phase 2 â€” Session Analysis\n5. Session file locator (find `chatSessions/` for current workspace)\n6. Session parser (extract agent usage, model, timestamps, tool calls)\n7. Metrics collector (aggregate across sessions)\n8. Metrics dashboard webview panel\n\n### Phase 3 â€” Session Explorer\n9. Session timeline view\n10. Request detail view\n11. Agent switching visualization\n\n### Phase 4 â€” Polish\n12. File watchers for live updates\n13. Metrics caching\n14. Export functionality\n15. Settings/configuration\n16. Marketplace icon and README\n\n---\n\n## 12. Open Questions\n\n- **Skill usage inference:** The session JSON doesn't have a clean \"skill X was loaded\" field. Skills are injected into the system prompt. Can we detect skill usage by matching skill names/descriptions in the response metadata? Or do we need to parse the system prompt from the Chat Debug view somehow? For MVP, we may just show skills as \"defined but usage unknown\" and only track agent-level usage.\n\n- **Agent ID mapping:** Custom agent IDs in session JSON â€” how exactly do they appear? Do they match the filename (e.g. `planner` for `planner.agent.md`)? Need to verify with real session data. Built-in agents use IDs like `github.copilot.editsAgent`.\n\n- **SpecStory compatibility:** Should we also support reading `.specstory/history/` markdown files as an alternative/supplementary data source? SpecStory auto-saves all Copilot chats as structured markdown and has growing adoption.\n\n---\n\n## 13. Naming & Publishing\n\n- **Extension ID:** `copilot-lens`\n- **Display name:** `Copilot Lens`\n- **GitHub repo:** `copilot-lens` (or `vscode-copilot-lens`)\n- **Description:** \"Visualize your GitHub Copilot agents, skills, and handoffs as an interactive graph. Parses chat sessions to surface usage metrics â€” which agents run, how often, and how sessions flow.\"\n- **Categories:** Visualization, Other\n- **Keywords:** copilot, github-copilot, agents, skills, handoffs, visualization, metrics, debug, graph, agent-mode\n````"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UB8Ln8t7L18acmAbhZE7XV"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "The `docs/research/` folder is currently empty â€” the document you mentioned may not have been saved there yet. Could you check?\n\nTo your two questions:\n\n**Does it have to be TypeScript?**\n\nFor the extension host code: practically, yes. VS Code extensions run in a Node.js host, so your options are TypeScript or plain JavaScript. TypeScript is the overwhelming standard â€” the API typings (`@types/vscode`) make development dramatically easier, and every VS Code extension template, doc, and example uses it. You *could* write plain JS, but you'd be fighting the tooling for no gain.\n\nFor the **webview** code (the D3 graph, charts, UI), you have more freedom. The spec calls for Lit + D3.js, which runs as plain web content inside an iframe. That part could be written in JS, TypeScript, or even compiled from Rust/WASM if you wanted â€” though that'd be overkill here. Lit + D3 in TypeScript is a solid, conventional choice.\n\n**TL;DR:** TypeScript isn't a hard technical *requirement*, but it's the only practical choice for the extension host. There's no meaningful alternative that wouldn't make your life harder.\n\n**Should we develop inside a container?**\n\nI'd say **no, not for this project**. Reasons:\n\n- VS Code extension development relies on the **Extension Development Host** (F5 to launch a second VS Code window). This works seamlessly locally but adds friction in a container (you'd need the Dev Containers extension, X11/Wayland forwarding or a headless setup).\n- The dependency footprint is light â€” just Node.js, npm, and TypeScript. No databases, no system-level dependencies, no platform-specific native modules.\n- The project reads local files (`~/.copilot/skills/`, VS Code's `workspaceStorage/`). Running inside a container would mean those paths don't exist or need bind-mounts, complicating exactly the thing you're trying to build and test.\n\nA `.devcontainer` could be nice *later* for contributors, but for active development it'd add overhead with no real benefit here. A simple `engines` field in `package.json` and a `node -v` check is enough to keep the dev environment consistent.\n\nWant to iterate on the spec before scaffolding, or is there a specific part you'd like to dig into?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\nwhat about a testing strategy, can you discuss that?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n   "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH",
                    "type": "function"
                  },
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\": \"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\", \"startLine\": 1, \"endLine\": 100}"
                    },
                    "id": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_015XnXtUaLhZnpdB5hL3omCH"
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
                  }
                ],
                "toolCallId": "toolu_vrtx_01UffNP2aVzhNoarWfMzQbgq"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good question â€” testing is where the architecture of this project actually makes it pretty pleasant. Here's how I'd think about it:\n\n## Three layers, two test runners\n\nThe codebase splits naturally into **pure logic** (parsers, analyzers, models) and **VS Code integration** (tree views, webview panels, commands). This means two different test strategies:\n\n### 1. Unit tests (Vitest) â€” the bulk of your tests\n\nThese cover everything that doesn't touch the VS Code API:\n\n- **`agentParser`** â€” Given a string of markdown with YAML frontmatter, does it produce the right `Agent` model? Feed it real `.agent.md` content, malformed content, missing fields, empty frontmatter, etc.\n- **`skillParser`** â€” Same idea. Test personal skill paths, missing descriptions, etc.\n- **`sessionParser`** â€” Given a session JSON blob, does it extract the right requests, agent IDs, models, timestamps? Test with truncated files, massive arrays, missing fields, version mismatches.\n- **`graphBuilder`** â€” Given a set of parsed agents and skills, does it produce the correct nodes and edges? Test handoff chains, circular handoffs, agents referencing nonexistent targets, orphan skills.\n- **`metricsCollector`** â€” Given parsed sessions, are the aggregations correct? Agent frequency counts, model distributions, date bucketing.\n- **`frontmatterParser`** â€” Edge cases: no frontmatter, unclosed `---`, empty YAML, special characters.\n\nThese are fast, isolated, and follow TDD naturally. Per your conventions: test files live next to source (`agentParser.test.ts` beside `agentParser.ts`), use `describe`/`it`/`expect`, mock only external dependencies (like `fs` reads).\n\nThis layer probably covers **80%+ of the meaningful logic** in the project.\n\n### 2. Integration tests (`@vscode/test-electron`) â€” lighter touch\n\nThese verify that the extension activates correctly and that VS Code API wiring works:\n\n- Extension activates when `.github/agents/` exists\n- Commands register and are callable\n- Tree view populates with the right structure\n- Webview panels open without crashing\n- File watchers trigger re-parsing\n\nThese are slower (they launch a real VS Code instance), so keep them focused on *integration plumbing* rather than logic. Don't re-test that the parser parses correctly â€” just test that the parser *gets called* when the extension activates.\n\n### 3. Webview UI â€” the tricky part\n\nThe Lit + D3 code runs in a browser context, not Node.js. Options:\n\n- **Don't unit-test D3 rendering.** Force-directed graph layout is inherently visual and non-deterministic. Testing that \"node X is at position (142, 307)\" is fragile and meaningless.\n- **Do test the data transformation** that feeds D3. The function that takes a graph model and produces the D3 nodes/links array â€” that's pure logic, testable with Vitest.\n- **Do test Lit components** if they have meaningful logic (filtering, search, state management). Use `@open-wc/testing` or just run Lit components in a jsdom/happy-dom environment.\n- **Consider a few snapshot/visual smoke tests** later (Phase 4) if you want â€” e.g., Playwright opening the webview and checking that the graph container renders *something*.\n\n## What I'd skip (at least initially)\n\n- **E2E tests against real Copilot session files.** These files are user-specific, huge, and contain private data. Instead, create small fixture files with realistic structure in a `test/fixtures/` directory.\n- **Testing the `sessionLocator`** that finds `chatSessions/` on disk. This is inherently platform-dependent and relies on VS Code internals. Test it manually, maybe write a thin integration test, but don't over-invest here.\n\n## Practical setup\n\n```\nvitest.config.ts          â†’ runs unit tests (fast, no VS Code)\n.vscode-test.mjs          â†’ runs integration tests (launches VS Code)\ntest/fixtures/\n  â”œâ”€â”€ agents/             â†’ sample .agent.md files (valid, malformed, edge cases)\n  â”œâ”€â”€ skills/             â†’ sample SKILL.md files\n  â””â”€â”€ sessions/           â†’ small synthetic session JSON files\n```\n\nThe key insight: **the spec already separates pure logic from VS Code glue pretty well.** If you keep that boundary clean during implementation â€” parsers and analyzers never import `vscode` â€” unit testing stays trivial and covers the hard parts. The VS Code integration layer is thin wiring that gets a lighter touch.\n\nWant to nail down the fixture data format, or talk about how to structure the test/fixtures for session data specifically?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\nTerminals:\nTerminal: zsh\n\n</context>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\nFor maximum efficiency, whenever you plan to perform multiple independent edit operations, invoke them simultaneously using multi_replace_string_in_file tool rather than sequentially. This will greatly improve user's cost and time efficiency leading to a better user experience. Do not announce which tool you're using (for example, avoid saying \"I'll implement all the changes using multi_replace_string_in_file\").\nDo NOT create a new markdown file to document each change or summarize your work unless specifically requested by the user.\n\n</reminderInstructions>\n<userRequest>\ncan you plan a feature?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "\n\n  "
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "ask_questions",
                      "arguments": "{\"questions\": [{\"header\":\"Feature\",\"question\":\"Which feature would you like me to plan? The spec has a clear phasing â€” I'd suggest starting with the Phase 1 MVP foundations.\",\"options\":[{\"label\":\"Agent/Skill parser\",\"description\":\"Parse .agent.md and SKILL.md files into data models\",\"recommended\":true},{\"label\":\"Graph builder\",\"description\":\"Build the node/edge graph model from parsed agents and skills\"},{\"label\":\"Sidebar tree view\",\"description\":\"Tree view listing agents, skills, and handoffs in the activity bar\"},{\"label\":\"Interactive graph webview\",\"description\":\"D3 force-directed graph visualization panel\"},{\"label\":\"Session parser + metrics\",\"description\":\"Parse chat session JSON files and aggregate usage metrics\"}],\"allowFreeformInput\":true}]}"
                    },
                    "id": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "{\"answers\":{\"Feature\":{\"selected\":[\"Interactive graph webview\"],\"freeText\":null,\"skipped\":false}}}"
                  }
                ],
                "toolCallId": "toolu_vrtx_01Qj2Ynb57vGx5azp6HQd9xs"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 1,
                    "text": "Good pick â€” though it sits at the top of a dependency chain. You can't render a graph without graph data, and you can't build graph data without parsing agents and skills first. So the plan needs to build upward.\n\nHere's how I'd break it down:\n\n---\n\n## Feature Plan: Interactive Agent/Skill Graph\n\n### Goal\nOpen a webview panel showing a D3 force-directed graph where agent nodes connect to other agents via handoff edges, and skill nodes are displayed alongside them. Clicking a node shows details.\n\n### Dependencies to build first (thin vertical slice)\n\nThese are *just enough* to feed the graph â€” not the full-featured versions from the spec.\n\n**Step 1 â€” Data models** (`models/agent.ts`, `models/skill.ts`, `models/graph.ts`)\n\nDefine the TypeScript interfaces:\n\n```typescript\n// agent.ts\ninterface Agent {\n  name: string;\n  filename: string;          // e.g. \"planner\" (from planner.agent.md)\n  description: string;\n  tools: string[];\n  model: string[];\n  handoffs: Handoff[];\n  body: string;              // markdown instructions\n}\ninterface Handoff {\n  label: string;\n  agent: string;             // target agent filename\n  prompt: string;\n  send: boolean;\n}\n\n// skill.ts\ninterface Skill {\n  name: string;\n  dirname: string;           // folder name under .github/skills/\n  description: string;\n  body: string;\n}\n\n// graph.ts\ninterface GraphNode {\n  id: string;\n  type: 'agent' | 'skill';\n  label: string;\n  description: string;\n  metadata: Record<string, any>;  // tools, model, etc.\n}\ninterface GraphEdge {\n  source: string;            // node id\n  target: string;            // node id\n  label: string;             // handoff label\n  style: 'solid' | 'dashed'; // send:true vs send:false\n}\ninterface GraphModel {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n```\n\nTDD: These are just types â€” no tests needed yet.\n\n**Step 2 â€” Frontmatter parser** (`utils/frontmatterParser.ts`)\n\nPure function: `string â†’ { data: Record<string, any>; body: string }`\n\nTests (Vitest):\n- Valid frontmatter with all fields â†’ correct data + body\n- No frontmatter â†’ empty data, full body\n- Unclosed `---` â†’ graceful fallback\n- Empty YAML block â†’ empty data object\n- Special characters in YAML values\n\n**Step 3 â€” Agent parser** (`parsers/agentParser.ts`)\n\nPure function: `(filename: string, content: string) â†’ Agent`\n\nTests:\n- Full agent file â†’ all fields populated\n- Missing optional fields (no `model`, no `handoffs`) â†’ defaults\n- Empty tools array vs missing tools\n- Multiple handoffs with different `send` values\n- Malformed YAML â†’ doesn't crash, returns partial\n\n**Step 4 â€” Skill parser** (`parsers/skillParser.ts`)\n\nPure function: `(dirname: string, content: string) â†’ Skill`\n\nTests:\n- Standard skill file â†’ correct name, description, body\n- Missing name field â†’ falls back to dirname\n- Empty body\n\n**Step 5 â€” Graph builder** (`analyzers/graphBuilder.ts`)\n\nPure function: `(agents: Agent[], skills: Skill[]) â†’ GraphModel`\n\nTests:\n- Two agents with handoff between them â†’ 2 nodes, 1 edge\n- Agent with `send: true` handoff â†’ solid edge style\n- Agent with `send: false` handoff â†’ dashed edge style\n- Handoff to nonexistent agent â†’ edge still created (dangling ref, maybe flagged)\n- Skills included as separate node type\n- No agents, no skills â†’ empty graph\n- Circular handoffs (A â†’ B â†’ A) â†’ valid graph (cycles allowed)\n- Agent with no handoffs â†’ isolated node, no edges\n\n### The actual webview (the feature itself)\n\n**Step 6 â€” Graph panel extension host side** (`views/graphPanel.ts`)\n\nThis is the VS Code webview panel wrapper. Responsibilities:\n- Create/show a webview panel (`vscode.window.createWebviewPanel`)\n- Load the webview HTML\n- Read `.github/agents/` and `.github/skills/` files from workspace\n- Parse them using the parsers\n- Build the graph model\n- Send the `GraphModel` to the webview via `postMessage`\n- Handle messages back from the webview (e.g., \"node clicked\")\n\nIntegration test: panel opens without error, receives graph data.\n\n**Step 7 â€” Graph webview UI** (`webview/graph.ts`, `webview/graph.html`)\n\nThe D3 force-directed graph rendered in the webview:\n\n- Listen for `postMessage` with graph data\n- Render nodes as circles/rects with labels (color-coded: agents vs skills)\n- Render edges as lines/arrows with labels (solid vs dashed for send behavior)\n- Force simulation for layout (d3-force)\n- Zoom + pan (d3-zoom)\n- Click node â†’ show detail panel (side panel or overlay with name, description, tools, model, body)\n- Hover â†’ tooltip with summary\n\nTests:\n- **Data transform function** (GraphModel â†’ D3 nodes/links arrays): unit testable with Vitest\n- **D3 rendering**: not unit tested â€” verified manually in Extension Development Host\n- **Message handling**: unit test the handler function that processes incoming messages\n\n**Step 8 â€” Command + activation wiring** (`extension.ts`)\n\n- Register `copilot-lens.openGraph` command\n- Command handler creates/shows the graph panel\n- Wire up activation events\n\nIntegration test: command is registered after activation.\n\n### Ordering & TDD flow\n\n```\nStep 1  Models (types only)               â†’ no tests\nStep 2  Frontmatter parser                â†’ 5-6 unit tests\nStep 3  Agent parser                      â†’ 5-6 unit tests\nStep 4  Skill parser                      â†’ 3-4 unit tests\nStep 5  Graph builder                     â†’ 7-8 unit tests\nStep 6  Graph panel (extension host)      â†’ 1-2 integration tests\nStep 7  Webview UI (D3 + Lit)             â†’ 2-3 unit tests on data transform\nStep 8  Command wiring                    â†’ 1 integration test\n                                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                                          ~25 tests total\n```\n\nSteps 2-4 can be parallelized. Step 5 depends on 2-4. Steps 6-8 depend on 5.\n\n### Test fixtures needed\n\n```\ntest/fixtures/\n  agents/\n    planner.agent.md          # full-featured agent with handoffs\n    simple.agent.md           # minimal agent, no handoffs\n    malformed.agent.md        # bad YAML\n  skills/\n    webapp-testing/SKILL.md   # standard skill\n    empty-skill/SKILL.md      # minimal/empty skill\n```\n\n### What's explicitly out of scope\n\n- Metrics overlay on the graph (Phase 2)\n- Built-in agent nodes (behind a setting, later)\n- Tool nodes as separate graph elements (optional in spec)\n- File watchers for live refresh (Phase 4)\n- Search/filter UI in the webview (can layer on after MVP)\n\n---\n\nWant me to start building this, or refine any part of the plan first?"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nlet's plan one of the prerequisites that are needed before we can create a diagram\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "dbfWwxu4gJEllzceFrtrkMtSGR/HNRRtU5IEF7GyDF9qGMopA/RJzY1peXxyVbwJYAGZR27xJwzSKreSfvTIg9ilcqSR3WloWwMQ1byKwFViiPSMobuc70/98/ZClpiGS3sZXZNzX2WHo7HmhPTRMQ4csrF9Fy8qb7oMU+b3hMCBE5Zoa2l4WbbQ057vC2ApTc4+P5D/xzvf+jaV659fibSr6AveE+Nv/726eqkDVHqjFXpqpqf26PyGdTN+7ISgBdZPo6s2glIjfHjapGU3+QUPTUpLK1zocQOB2Oj1a5beLX2cLSErbRU5Vnwyc7INu00a7YPBMJOkQ9VxRQeRP5NbtZvMmSNJKP+KXIE0jXbEK06U5IOkHdomnKpHumoNlcz9SECyvGSYiHhO9snQtNt16z1sOe9N"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll quickly review your current research note so the prerequisite plan fits what youâ€™ve already captured, then Iâ€™ll propose an ordered implementation plan you can execute immediately."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md\",\"startLine\":1,\"endLine\":260}"
                    },
                    "id": "call_7qYVpRx7gDjHhPLDt6nk4Bvc",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "File: `/Users/peterbru/Dropbox/Projects/copilot-lens/docs/research/data-sources.md`. Lines 1 to 260 (364 lines total): \n````markdown\n# Data Sources Research\n\n> Findings from analyzing real Copilot chat data on disk. This documents what's actually available, how to access it, and how it differs from the assumptions in the original design spec.\n\n---\n\n## 1. Where Copilot Chat Data Lives\n\n### Workspace storage (auto-discoverable)\n\n```\n{UserDataRoot}/User/workspaceStorage/{WorkspaceHash}/chatSessions/{SessionId}.jsonl\n```\n\nPlatform paths for `{UserDataRoot}`:\n- **macOS:** `~/Library/Application Support/Code/` (or `Code - Insiders`)\n- **Windows:** `%APPDATA%/Code/`\n- **Linux:** `~/.config/Code/`\n\nEach VS Code workspace gets a hash directory. Inside it:\n- `workspace.json` â€” maps the hash to the actual workspace path\n- `chatSessions/` â€” one file per chat session\n- `state.vscdb` â€” SQLite database with session index\n\n### Session index (SQLite)\n\n```bash\nsqlite3 state.vscdb \"SELECT value FROM ItemTable WHERE key = 'chat.ChatSessionStore.index';\"\n```\n\nReturns JSON:\n```json\n{\n  \"version\": 1,\n  \"entries\": {\n    \"<sessionId>\": {\n      \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n      \"title\": \"Design specification and development environment questions\",\n      \"lastMessageDate\": 1770929089337,\n      \"timing\": {\n        \"created\": 1770929049693,\n        \"lastRequestStarted\": 1770929089337,\n        \"lastRequestEnded\": 1770929154460\n      },\n      \"initialLocation\": \"panel\",\n      \"hasPendingEdits\": false,\n      \"isEmpty\": false,\n      \"isExternal\": false,\n      \"lastResponseState\": 1\n    }\n  }\n}\n```\n\nThis lets us list all sessions with titles and timestamps without parsing the full session files.\n\n### Finding the right workspace from an extension\n\n```typescript\n// context.storageUri gives the extension's own storage dir:\n//   workspaceStorage/{hash}/copilot-lens/\n// Navigate up twice to get the workspace storage root:\nconst extensionStorageDir = context.storageUri?.fsPath;\nconst workspaceHashDir = path.dirname(extensionStorageDir);\nconst chatSessionsDir = path.join(workspaceHashDir, 'chatSessions');\n```\n\n### Global storage (Copilot Chat extension)\n\n```\n{UserDataRoot}/User/globalStorage/github.copilot-chat/\nâ”œâ”€â”€ commandEmbeddings.json    # 25MB â€” embeddings cache\nâ”œâ”€â”€ toolEmbeddingsCache.bin   # Tool embeddings\nâ”œâ”€â”€ debugCommand/             # copilot-debug CLI\nâ”œâ”€â”€ copilotCli/               # CLI shims\nâ”œâ”€â”€ logContextRecordings/     # Empty\nâ””â”€â”€ plan-agent/Plan.agent.md  # Plan agent definition\n```\n\nNo session data here â€” it's all in workspace storage.\n\n---\n\n## 2. Session File Format: JSONL (Current)\n\nNewer sessions (all sessions in our test workspace) use `.jsonl` â€” one JSON object per line with incremental patches.\n\n### Line types\n\n| `kind` | Purpose | Key path `k` | Value `v` |\n|--------|---------|--------------|-----------|\n| `0` | Session header | n/a | Full session object with `version`, `sessionId`, `creationDate`, `inputState` |\n| `1` | Property update | Path array, e.g. `[\"customTitle\"]` or `[\"requests\", 0, \"result\"]` | The new value |\n| `2` | Array append | Path array, e.g. `[\"requests\"]` or `[\"requests\", 2, \"response\"]` | Array of items to append |\n\n### kind=0: Session header\n\n```json\n{\n  \"kind\": 0,\n  \"v\": {\n    \"version\": 3,\n    \"creationDate\": 1770929049693,\n    \"initialLocation\": \"panel\",\n    \"responderUsername\": \"GitHub Copilot\",\n    \"sessionId\": \"25360328-3a13-44a3-bf95-989d6618e9aa\",\n    \"hasPendingEdits\": false,\n    \"requests\": [],\n    \"inputState\": {\n      \"attachments\": [],\n      \"mode\": { \"id\": \"agent\", \"kind\": \"agent\" },\n      \"selectedModel\": {\n        \"identifier\": \"copilot/claude-opus-4.6\",\n        \"metadata\": {\n          \"id\": \"claude-opus-4.6\",\n          \"name\": \"Claude Opus 4.6\",\n          \"family\": \"claude-opus-4.6\",\n          \"maxInputTokens\": 127805,\n          \"maxOutputTokens\": 64000,\n          \"capabilities\": { \"vision\": true, \"toolCalling\": true, \"agentMode\": true }\n        }\n      },\n      \"inputText\": \"...\"\n    }\n  }\n}\n```\n\n### kind=1: Property updates\n\n```json\n{\"kind\": 1, \"k\": [\"customTitle\"], \"v\": \"Design specification and development environment questions\"}\n{\"kind\": 1, \"k\": [\"requests\", 0, \"result\"], \"v\": { \"timings\": {...}, \"metadata\": {...} }}\n{\"kind\": 1, \"k\": [\"inputState\", \"inputText\"], \"v\": \"\"}\n```\n\n### kind=2: Request data (the main payload)\n\n```json\n{\n  \"kind\": 2,\n  \"k\": [\"requests\"],\n  \"v\": [{\n    \"requestId\": \"request_5de388ab-2cea-44aa-acf0-13da44da801f\",\n    \"timestamp\": 1770929089337,\n    \"agent\": {\n      \"extensionId\": { \"value\": \"GitHub.copilot-chat\" },\n      \"id\": \"github.copilot.editsAgent\",\n      \"name\": \"agent\",\n      \"fullName\": \"GitHub Copilot\",\n      \"isDefault\": true,\n      \"modes\": [\"agent\"]\n    },\n    \"modelId\": \"copilot/claude-opus-4.6\",\n    \"responseId\": \"response_df736250-4e24-4f3d-8da7-fe2bc959ecd0\",\n    \"message\": { \"text\": \"I put a document in docs/research...\" },\n    \"response\": [\n      { \"kind\": \"mcpServersStarting\", \"didStartServerIds\": [] },\n      { \"kind\": \"progressTaskSerialized\", \"content\": { \"value\": \"Optimizing tool selection...\" } },\n      { \"kind\": \"thinking\", \"value\": \"Let me first look at...\", \"id\": \"thinking_1\" },\n      { \"kind\": \"toolInvocationSerialized\", \"toolId\": \"copilot_listDirectory\", \"toolCallId\": \"...\" },\n      { \"value\": \"markdown response text...\", \"supportThemeIcons\": false }\n    ]\n  }]\n}\n```\n\n### Result metadata (set via kind=1 patch after request completes)\n\n```json\n{\n  \"kind\": 1,\n  \"k\": [\"requests\", 0, \"result\"],\n  \"v\": {\n    \"timings\": {\n      \"firstProgress\": 3659,\n      \"totalElapsed\": 44202\n    },\n    \"metadata\": {\n      \"agentId\": \"github.copilot.editsAgent\",\n      \"promptTokens\": 28857,\n      \"outputTokens\": 1107,\n      \"renderedUserMessage\": [...],\n      \"toolCallRounds\": [\n        {\n          \"id\": \"...\",\n          \"response\": \"...\",\n          \"thinking\": \"...\",\n          \"toolCalls\": [\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" },\n            { \"id\": \"toolu_vrtx_...\", \"name\": \"read_file\" }\n          ],\n          \"toolInputRetry\": 0\n        }\n      ],\n      \"toolCallResults\": { \"<toolCallId>\": { \"content\": [...] } },\n      \"codeBlocks\": [],\n      \"modelMessageId\": \"...\",\n      \"responseId\": \"...\",\n      \"sessionId\": \"...\"\n    },\n    \"usage\": {\n      \"completionTokens\": 1107,\n      \"promptTokens\": 28857,\n      \"promptTokenDetails\": [\n        { \"category\": \"System\", \"label\": \"System Instructions\", \"percentageOfPrompt\": 13 },\n        { \"category\": \"System\", \"label\": \"Tool Definitions\", \"percentageOfPrompt\": 56 },\n        { \"category\": \"User Context\", \"label\": \"Messages\", \"percentageOfPrompt\": 7 },\n        { \"category\": \"User Context\", \"label\": \"Tool Results\", \"percentageOfPrompt\": 24 }\n      ]\n    }\n  }\n}\n```\n\n---\n\n## 3. Session File Format: JSON (Legacy)\n\nOlder sessions use a monolithic `.json` file â€” same schema as the kind=0 header but with `requests[]` fully populated. The spec's `CopilotChatSession` interface was roughly based on this format. We found no `.json` files in our test workspace (created Feb 2026), suggesting VS Code has migrated fully to JSONL.\n\n**Decision:** Support both formats. Parse JSONL as primary, fall back to monolithic JSON for older sessions.\n\n---\n\n## 4. Chat Replay Export Format (.chatreplay.json)\n\nProduced by: `Developer: Show Chat Debug View` â†’ right-click â†’ `Export As...`\n\n**Cannot be automated.** The export command lives inside the `github.copilot-chat` extension, requires UI interaction (tree node selection + file save dialog), and Microsoft explicitly closed a request for programmatic export as \"out of scope\" ([issue #228144](https://github.com/microsoft/vscode/issues/228144)).\n\n### Schema\n\n```json\n{\n  \"exportedAt\": \"2026-02-12T21:13:03.592Z\",\n  \"totalPrompts\": 4,\n  \"totalLogEntries\": 18,\n  \"prompts\": [\n    {\n      \"prompt\": \"user's message text\",\n      \"promptId\": \"12ed2d39-prompt\",\n      \"hasSeen\": false,\n      \"logCount\": 11,\n      \"logs\": [\n        {\n          \"id\": \"12ed2d39\",\n          \"kind\": \"request\",\n          \"type\": \"ChatMLSuccess\",\n          \"name\": \"panel/editAgent\",\n          \"metadata\": {\n            \"model\": \"claude-opus-4.6\",\n            \"duration\": 4857,\n            \"timeToFirstToken\": 2732,\n            \"startTime\": \"2026-02-12T21:04:30.522Z\",\n            \"endTime\": \"2026-02-12T21:04:35.379Z\",\n            \"usage\": {\n              \"prompt_tokens\": 20871,\n              \"completion_tokens\": 214\n            },\n````"
                  }
                ],
                "toolCallId": "call_7qYVpRx7gDjHhPLDt6nk4Bvc"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "Tb7Mk/OdP83ikMC3Z2o6myxg2lUYL/vMxpysstXIFcmeqC6WkVpp9i+VEIeaOHt1lvllC7HXRfGzjxvwsswr0M72lFI7fCeCKYnVL2RtMCkyKTt3Nm/926QC8GONo7uZ2v6d5gXpZe/EoDJxSvlC/2M7dexx8ZvhnVcdaRttVlhZt79qX7jDSZB6a+SQbRVEl/8DTyG3GSm8hxRJVH6oZofIIQzgaimC6BzLvAUahKM4RdCHZUsnvg74+nAwrHATUDRjBx08Zvo4Pdm6/whad6OlUaGA8uvchwX2VkOQWGD+u7XuqA4xLu8TmbrMabV/6TvhOyM/dvMCoY9ZKonfYli99/LZziuGyNHZV4NvE6xse96SYbQEdNcZZv6sHI61mgSGhLVnTLzDXOI39ThfnIAdj0KUV34w"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Perfect next prerequisite to plan: **a unified parser + normalization layer for agent/skill files**.  \nWithout this, the diagram has no trustworthy graph input.\n\n**Prerequisite Scope**\n- Build one pipeline that reads `.github/agents/*.agent.md` and `.github/skills/*/SKILL.md`.\n- Normalize both into a stable internal graph-ready contract (nodes + handoff edges).\n- Validate and surface parse warnings (missing names, bad YAML, unknown handoff targets).\n\n**Ordered Plan**\n- 1) Define domain contract: `Agent`, `Skill`, `Handoff`, `GraphNode`, `GraphEdge`, plus `ParseWarning`.\n- 2) Implement frontmatter/body extraction with safe fallbacks (never throw on malformed docs).\n- 3) Implement `agentParser` and `skillParser` as pure functions (string in â†’ model out).\n- 4) Implement `graphBuilder` that maps parsed models to nodes/edges and marks unresolved links.\n- 5) Add fixture-driven Vitest unit tests (happy path + malformed + missing fields + cycles).\n- 6) Add a thin extension-host adapter that scans workspace files and returns one `GraphModel`.\n\n**Key Technical Decisions**\n- Treat parsing as **best-effort**: partial output + warnings beats hard failure.\n- Use stable node IDs from filenames/skill dirs so future metrics can join reliably.\n- Keep all parsing/analyzing logic independent of VS Code APIs for fast tests.\n\n**Risks / Open Questions**\n- Handoff target naming may not always match filename; need explicit mapping rule.\n- YAML variance across real repos can be high; decide strict vs permissive coercion.\n- Personal skills (`~/.copilot/skills`) can wait until this prerequisite is green.\n\n**Definition of Done**\n- Given fixtures, `graphBuilder` returns deterministic nodes/edges and warning list.\n- â‰¥90% coverage on parsers/analyzer modules.\n- Extension can call one function and receive a graph-ready payload for webview rendering.\n\nIf you want, I can plan the *next* prerequisite in the chain right after this: session JSONL ingestion for usage overlays."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\n@planner am I using the planner now?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "pvJnsOF5ifEL2WGpFv001bVoPpozy6xl4sIQYKrSk2tfyEVkRg8skBlm3is6q6R+pj/h6G6v+LkdGvRX76LPmQR5BjqHIGIBvG8XmNRP5+JakeDHfYg6epPbsnAGqPoMJHvQo3HbqdrN7LzdQ8/kYdRw1hXEqMJ7k8+yyTrwnVEIU9Ip91CL05NVzgu/3hsfuzvKYRWDM/VTzxPSMlSChjD1UDppHALAls16ZbnQX/z/Rva2TybpMvETRu0FvW9MZA533Wf9s6f/WC/e+sXKSpYWeo/kwFNrIW17wxXG2e5c++os2Zbpy0nmyVzcH8LqK9IYa3ScBlzsUAvhiMuptTcW9l5uKg+wTdPivM4D2pLyxdgvVIdUzkiUMLsFh+jBXzUPGSkQm6nlgSt/cWaHZIKOqWgF6iRa"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Yes â€” in this chat Iâ€™m operating in Planner mode, so Iâ€™m focused on design/implementation planning rather than writing code changes immediately.  \n\nIf you want, I can switch from planning to an execution-style breakdown next (task-by-task with concrete file targets)."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok so choosing the planner from the dropdown didn't select the planner apparently. I had to type @Planner. Comments?\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "9ABPeSTecOmQOVyco140nt1VGDRfdkGLIMCjqzyaxaJZxlEzpvSTpoXMznjCNSkevgmMukO9LuKwkKjVDipvrGwkMJTkgFkzA3s3m094vQhzlQ3yw9wDQRr4Lm9e6CjHBDel6fqc+RMD5va6DTVHwIB+zFCuI/dL/2MVn05ILIksQl3PpXB5lWHh3X2Y55c6UiSSuXBFN34CrV6tEphRFLVYddL0lN00o/twIqZHjHCor77VMp+9brycTZOl3IEI6Vniizrvb0Zza7q/WHPqgGlH/96sDoY88bOwhUnI3Ku9aYntMCtdXkQY2FfusCE6jt7QGGX8TOij2lci+e72vEbvOO4nqj2njhjZAOPI6kRiIoMRJocAuiIVyQZ8jcvUTu2c6YaumhfWeV7H387snoGzPeDRmbyX"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "That behavior is plausible, and youâ€™re not imagining it.\n\nMost likely what happened is:\n- The dropdown changed the intended agent/mode in UI state, but the actual turn still routed through the default assistant context.\n- Typing `@Planner` in-message forced explicit agent routing, so it worked reliably.\n\nMy practical take:\n- Treat explicit `@Planner` as the deterministic path for now.\n- If dropdown selection is inconsistent, itâ€™s often a UI/state sync issue (especially after edits to agent files).\n- Quick stabilizers: reload window, re-open chat, and make sure agent metadata/name is valid and unique.\n\nIf you want, I can give you a short â€œagent routing sanity checklistâ€ you can run in under 2 minutes whenever this happens."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nok\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "XrwDJY0+r3Ba9qUoxgvqijdvfVAFsUsbXarOQESloBO8rOnJnTdEp439A/aWHmcWZtX72WXZwxyrURrRGMcuHEBrEjXSGxHsE6faodipHTNvGVvlJ1cJ5tdbG54XSKXl5JEcfVpOWLP1rE8VqKAkZ+bA3oFlPqCLLksJvdgo4LlMOvZH0VMDWbcYksepVFRERnBwTlDHO50PAYtQxPE9878Qj43yAyurJvDdD77PUIVcFKHvgcMHlPFRNyOWN8zyCBr/evz2Hy5aKQDPWtYz5Un+Vqsfoghqm9pK3oV2RyhNbsrW6f3YplHiZKrz9ScO7mzuBRXs+EZSi+y9+K2D9WXY/nyL69kKNgTQvX68W3P4IxsRknG8dP3K/gcstj5LN7mk8B8KH8u0UwdJ0vym/FRgQexSlrjm"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Use this quick checklist when agent routing feels off:\n\n- Confirm frontmatter in [`.github/agents/planner.agent.md`](.github/agents/planner.agent.md) has a valid `name` (exactly `Planner`) and no YAML errors.\n- Ensure there isnâ€™t another agent with the same `name` or confusingly similar casing.\n- Save all agent files, then run `Developer: Reload Window`.\n- Start a fresh chat turn and explicitly send `@Planner test` once to verify routing.\n- If dropdown still disagrees, trust explicit mention routing (`@Planner`) as the source of truth.\n- Capture one repro (dropdown choice + resulting agent ID in session/logs) so you can track it as a UI bug later.\n\nIf you want, I can review your planner frontmatter now for anything that might confuse dropdown selection."
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\nyes check the frontmatter\n</userRequest>\n"
                  }
                ]
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "rz5l1qynPw8MGv0tlz0QpNmeHIX016VE2J001Ikg5V+HRsrfVY9bKxPWi2KzTwj8Jv0qp9UcoEgQsUGAIEn/Tj7nA4/bWFH4ns0yTZVdmULMLmyBC06hddzGJQpvFYzxF0Gw2gSwtPRsRz/4RSwury1ircqrmNpH0w9JPCBhD/ifQNdw6chDh3YYGVPQna1Iu+JXpUZmfMeboh3WOvNaOm2u5XhAXHbWufhNDSujq1L730mXcGJXfUCjk5QvhmMMKAh4LD4Han7v7LItUyJtExq3Di+/1DA/hGj/hGSJx2liPmERYupedUGEQVFyt/EfyQhpQrS7kHumY9tzuVxhTTiKGviCZIoTAhWnzR2PiOd5URBfRUluwRGdFma3F9ZFF6r9TPiP7uTHsdnTxNvNn4Z2IOlUhuvp"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "commentary"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Iâ€™ll inspect the planner agent frontmatter for schema or formatting issues that could affect dropdown routing, then Iâ€™ll point out exact fixes if needed."
                  }
                ],
                "toolCalls": [
                  {
                    "function": {
                      "name": "read_file",
                      "arguments": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\",\"startLine\":1,\"endLine\":200}"
                    },
                    "id": "call_3tsfIXf98r3T4n0nNb0Jl1ol",
                    "type": "function"
                  }
                ]
              },
              {
                "role": 3,
                "content": [
                  {
                    "type": 1,
                    "text": "```chatagent\n---\nname: Planner\ndescription: Design and plan implementation tasks. Use this when discussing architecture, making technical decisions, or breaking down features into steps.\ntools: ['search', 'fetch', 'githubRepo']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Start Implementation\n    agent: implementer\n    prompt: Implement the plan outlined above.\n    send: false\n---\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n```"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ],
                "toolCallId": "call_3tsfIXf98r3T4n0nNb0Jl1ol"
              },
              {
                "role": 2,
                "content": [
                  {
                    "type": 2,
                    "value": {
                      "type": "stateful_marker",
                      "value": {
                        "modelId": "gpt-5.3-codex",
                        "marker": "ocmlystM39KutDqTjGbiLyqqSJMk3/ngGVAgV9Pt2IGoHYgWpyNCGBM8X/s3HmLP21XzibpM7YbNsMI2Oi0zUFxzoxKFp0M/3l3BrEgZHT/xQRrw4kLP51oGQX6/Y6WX2N66FfGr7Du5pp36wXaWtN+uilev4ERXcn0DIIZGOUCzBKPIt2ZkzUaPYJ7U/7B3awk0X+7AnPT7Mc6v7xbw4FzGr3KVnTWYzTcZ470ZSjZZHAQF1iE5jMaD2SXE0nsXOxTBeZdvMkW4Miy/DcVQ49vhtGsfxNGe4TI2NddWujV3i9jm8hZzLfrgaxyBvlGINg7VZWzJcC6EftVM3nr8ES6Ycaq0WqUcEu6woAn8FZuFn0ozfhcTKWC2EHE3hLEmYcBJwyA8qys8yaiakeB56W6XUeQh5G+Y"
                      }
                    }
                  },
                  {
                    "type": 2,
                    "value": {
                      "type": "phase_data",
                      "phase": "final_answer"
                    }
                  },
                  {
                    "type": 1,
                    "text": "Frontmatter looks valid and clean â€” nothing obviously broken for routing.\n\n- `name: Planner` is present and properly cased.\n- YAML structure is valid (`tools`, `model`, `handoffs` arrays all parse cleanly).\n- Delimiters are correct (`---` â€¦ `---`), and required top-level fields exist.\n\nOnly minor thing to watch:\n- `agent: implementer` in handoffs should correspond to an actual file like `.github/agents/implementer.agent.md`; this wonâ€™t affect selecting `Planner`, but it can affect handoff behavior later.\n\nSo your dropdown issue is likely not this fileâ€™s frontmatter. It still points to chat UI state/routing sync, where explicit `@Planner` is currently the reliable path.\n\nIf you want, I can quickly scan all files under `.github/agents/` for duplicate/conflicting `name` values next."
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "<context>\nThe current date is 12 February 2026.\n</context>\n<editorContext>\nThe user's current file is /Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md. \n</editorContext>\n<reminderInstructions>\nYou are an agentâ€”keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.\nTake action when possible; the user expects you to do useful work without unnecessary questions.\nAfter any parallel, read-only context gathering, give a concise progress update and what's next.\nAvoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.\nTool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.\nProgress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, report progress.\nRequirements coverage: Read the user's ask in full and think carefully. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.\n\n</reminderInstructions>\n<userRequest>\ncheck for all possible problems under .github/\n</userRequest>\n"
                  },
                  {
                    "type": 3,
                    "cacheType": "ephemeral"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Iâ€™ll audit `.github/` for issues that could impact agent loading, routing, or future parsing by scanning agent/skill files plus instructions for schema, naming, and structural inconsistencies."
            ]
          }
        },
        {
          "id": "call_Ns94tsOQL1RwBwpJg60YT9vO__vscode-1770929887303",
          "kind": "toolCall",
          "tool": "list_dir",
          "args": "{\"path\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github\"}",
          "time": "2026-02-12T22:13:51.805Z",
          "response": [
            "agents/\ncopilot-instructions.md\nskills/"
          ],
          "thinking": {
            "id": "bCj7BEpdBQfQHKGxcb+a8Klx3XD59nxPkJyD57MolwVBNILyd/9mDXWOaSdC6y3XpSWzD7j7IjmaQM7nhzdDLot/DY/oEcl5Hve5M9hCqh7bswCuX14onPJNkXeqN9lSaEaJVz8vsiN69diKSFU1hcQTKKQ3rsKoLZZ5uFFCekHlDgyAMhsgPz5WIVLVwuInXXgoGA6JlMAHo62J+xLkbBiWkX8SSghi6ygSSvcq3oiEscuz1UX0vUShhnsuNZB4mxiJf5OZLkOGWjQotSpw78BIc/1Wbp/Z8LBh8y2Lf+njpoFyKUFjERtGg6h0E9NgYJtQ9w1OSBCLXNWbLKzjOB+RuabxsqgUkagJm32J3YXAKmnVUd5A7AvGmIhy0/QH8NxEzLQb1rYtVNcP5HmYjameyxSTLw==",
            "text": "**Planning .github inspection**"
          }
        },
        {
          "id": "call_M8ubOPE8Nrb5AP7stuN3wnnh__vscode-1770929887304",
          "kind": "toolCall",
          "tool": "file_search",
          "args": "{\"query\":\".github/**/*.md\",\"maxResults\":200}",
          "time": "2026-02-12T22:13:51.805Z",
          "response": [
            "6 total results\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/implementer.agent.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/reviewer.agent.md"
          ],
          "thinking": {
            "id": "bCj7BEpdBQfQHKGxcb+a8Klx3XD59nxPkJyD57MolwVBNILyd/9mDXWOaSdC6y3XpSWzD7j7IjmaQM7nhzdDLot/DY/oEcl5Hve5M9hCqh7bswCuX14onPJNkXeqN9lSaEaJVz8vsiN69diKSFU1hcQTKKQ3rsKoLZZ5uFFCekHlDgyAMhsgPz5WIVLVwuInXXgoGA6JlMAHo62J+xLkbBiWkX8SSghi6ygSSvcq3oiEscuz1UX0vUShhnsuNZB4mxiJf5OZLkOGWjQotSpw78BIc/1Wbp/Z8LBh8y2Lf+njpoFyKUFjERtGg6h0E9NgYJtQ9w1OSBCLXNWbLKzjOB+RuabxsqgUkagJm32J3YXAKmnVUd5A7AvGmIhy0/QH8NxEzLQb1rYtVNcP5HmYjameyxSTLw==",
            "text": "**Planning .github inspection**"
          }
        },
        {
          "id": "call_93LF7EUkJ7kRi9jApI5PH2xr__vscode-1770929887305",
          "kind": "toolCall",
          "tool": "file_search",
          "args": "{\"query\":\".github/**/*.{md,json,yml,yaml}\",\"maxResults\":400}",
          "time": "2026-02-12T22:13:51.806Z",
          "response": [
            "6 total results\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/implementer.agent.md\n/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/reviewer.agent.md"
          ],
          "thinking": {
            "id": "bCj7BEpdBQfQHKGxcb+a8Klx3XD59nxPkJyD57MolwVBNILyd/9mDXWOaSdC6y3XpSWzD7j7IjmaQM7nhzdDLot/DY/oEcl5Hve5M9hCqh7bswCuX14onPJNkXeqN9lSaEaJVz8vsiN69diKSFU1hcQTKKQ3rsKoLZZ5uFFCekHlDgyAMhsgPz5WIVLVwuInXXgoGA6JlMAHo62J+xLkbBiWkX8SSghi6ygSSvcq3oiEscuz1UX0vUShhnsuNZB4mxiJf5OZLkOGWjQotSpw78BIc/1Wbp/Z8LBh8y2Lf+njpoFyKUFjERtGg6h0E9NgYJtQ9w1OSBCLXNWbLKzjOB+RuabxsqgUkagJm32J3YXAKmnVUd5A7AvGmIhy0/QH8NxEzLQb1rYtVNcP5HmYjameyxSTLw==",
            "text": "**Planning .github inspection**"
          }
        }
      ]
    },
    {
      "prompt": "check for all possible problems under .github/",
      "promptId": "b12f3c74-prompt",
      "hasSeen": true,
      "logCount": 7,
      "logs": [
        {
          "id": "dcd7f040",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T22:13:54.673Z",
            "endTime": "2026-02-12T22:13:55.103Z",
            "duration": 430,
            "ourRequestId": "09b63973-560b-4c02-b93a-437078f9db82",
            "requestId": "09b63973-560b-4c02-b93a-437078f9db82",
            "serverRequestId": "09b63973-560b-4c02-b93a-437078f9db82",
            "timeToFirstToken": 314,
            "usage": {
              "completion_tokens": 9,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1588,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1597
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github), Searching for files matching `**/.github/**/*.md`, Searching for files matching `**/.github/**/*.{md,json,yml,yaml}`, Planning parallel file inspection"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Reviewed .github and planned parallel file inspection"
            ]
          }
        },
        {
          "id": "call_mRda9dO9TXXTRbZsc0UThRLZ__vscode-1770929887306",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/implementer.agent.md\",\"startLine\":1,\"endLine\":220}",
          "time": "2026-02-12T22:13:58.049Z",
          "response": [
            "```chatagent\n---\nname: Implementer\ndescription: Write and modify code. Use this for implementing features, fixing bugs, and refactoring.\ntools: ['search', 'read', 'write', 'terminal', 'usages']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Review Code\n    agent: reviewer\n    prompt: Review the implementation above for correctness, edge cases, and style.\n    send: false\n  - label: Back to Planning\n    agent: planner\n    prompt: The implementation raised some questions. Let's revisit the plan.\n    send: false\n---\n\nYou are an implementation assistant. When writing code:\n\n1. Follow existing patterns in the codebase\n2. Write tests alongside implementation (TDD when possible)\n3. Keep changes minimal and focused\n4. Explain non-obvious decisions in comments\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        },
        {
          "id": "call_3a8pIZbvYH8UuoaJ7IsCG5gg__vscode-1770929887307",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/reviewer.agent.md\",\"startLine\":1,\"endLine\":220}",
          "time": "2026-02-12T22:13:58.049Z",
          "response": [
            "```chatagent\n---\nname: Reviewer\ndescription: Review code for correctness, style, and potential issues. Use this after implementation to catch problems.\ntools: ['search', 'read', 'usages']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Fix Issues\n    agent: implementer\n    prompt: Fix the issues identified in the review above.\n    send: false\n---\n\nYou are a code reviewer. When reviewing:\n\n1. Check for correctness and edge cases\n2. Look for security issues\n3. Verify test coverage\n4. Suggest simplifications where possible\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        },
        {
          "id": "call_V9FwdJlAoL5nUm1f2ddMCykQ__vscode-1770929887308",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md\",\"startLine\":1,\"endLine\":220}",
          "time": "2026-02-12T22:13:58.049Z",
          "response": [
            "```chatagent\n---\nname: Planner\ndescription: Design and plan implementation tasks. Use this when discussing architecture, making technical decisions, or breaking down features into steps.\ntools: ['search', 'fetch', 'githubRepo']\nmodel: ['Claude Sonnet 4.5', 'GPT-4o']\nhandoffs:\n  - label: Start Implementation\n    agent: implementer\n    prompt: Implement the plan outlined above.\n    send: false\n---\n\nYou are a planning assistant. When asked to plan or design something:\n\n1. Understand the requirements and constraints\n2. Identify key technical decisions\n3. Break the work into ordered steps\n4. Flag risks or open questions\n\nKeep plans concise and actionable.\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        },
        {
          "id": "call_yIIWDkSdozWxml5EHzRQ0CJQ__vscode-1770929887309",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md\",\"startLine\":1,\"endLine\":220}",
          "time": "2026-02-12T22:13:58.050Z",
          "response": [
            "```skill\n---\nname: testing\ndescription: Guide for writing tests. Use this when creating unit tests, integration tests, or setting up test infrastructure.\n---\n\n# Testing Patterns\n\n## TDD workflow\n1. Write a failing test (red)\n2. Write minimal code to pass (green)\n3. Refactor while keeping tests green\n\n## Vitest conventions\n- Test files: `*.test.ts` next to source files\n- Use `describe` / `it` blocks\n- Prefer `expect` assertions\n- Mock external dependencies, not internal logic\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        },
        {
          "id": "call_fJ5cDgwlPriKYma4eypscfG0__vscode-1770929887310",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md\",\"startLine\":1,\"endLine\":220}",
          "time": "2026-02-12T22:13:58.050Z",
          "response": [
            "```skill\n---\nname: vscode-extensions\ndescription: Guide for developing VS Code extensions. Use this when creating or modifying extension code, webviews, tree views, or commands.\n---\n\n# VS Code Extension Development\n\n## Extension structure\n- `extension.ts` â€” activation point, register commands and views\n- `package.json` â€” contributes commands, views, configuration\n- Webviews use message passing (`postMessage` / `onDidReceiveMessage`)\n\n## Webview security\n- Use `webview.asWebviewUri()` for local resources\n- Set a restrictive Content-Security-Policy\n- Bundle dependencies locally, never load from CDN\n\n## Testing\n- Use `@vscode/test-electron` for integration tests\n- Unit test pure logic separately with vitest\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        },
        {
          "id": "call_l68XhrTOW9ze9pEcbBCthkkP__vscode-1770929887311",
          "kind": "toolCall",
          "tool": "read_file",
          "args": "{\"filePath\":\"/Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md\",\"startLine\":1,\"endLine\":260}",
          "time": "2026-02-12T22:13:58.051Z",
          "response": [
            "```instructions\n# Copilot Lens â€” Project Instructions\n\nThis is a VS Code extension project called Copilot Lens. It visualizes GitHub Copilot agents, skills, and handoffs as an interactive graph, and analyzes chat session data for usage metrics.\n\n## Tech stack\n- TypeScript (extension host)\n- Lit + D3.js (webview UI)\n- Vitest (unit tests)\n- VS Code Extension API\n\n## Conventions\n- Follow TDD: red-green-refactor\n- Keep webview code separate from extension host code\n- Parse agent/skill files from `.github/agents/` and `.github/skills/`\n\n```"
          ],
          "thinking": {
            "id": "VFhnsqr08RbcJmzgbiIdD3rSlOIZW4zKSLdpPadzw1Z6HfmvECDouEzzA3S7OUE4q2hU4WpzPsf0bd9SpIlGQ8/wq4fDHgWBtYMld1YsNi+u+pEpt7wjaic4WJ1OuIFnGOuPNaMZFyOTm5O90a7BforgeYkmv+LwzNXxCS+nDH2qdadcYzLoAndigc8jJ1BAXC42hJAs39/7+Wk8rbAQImqsdNgSLkQZeXg/+ptDzyaMv/yVhI9NDsa/RjqpJdnvAWTXFjl8yshpTtDoth7yRvWuAMiNd0zi0xXi0SByonBdlKPoHCHe30a5G7BzlYREwJqCaCv7XrGMVT9YMV1eV2iZkIjs8FMrcsVrLiPWfled3Rt/zHxoo9UM1/O7u+SBAZJV5hnXfPs+waCGIhvQGUrWLz1MoQ==",
            "text": "**Planning parallel file inspection**"
          }
        }
      ]
    },
    {
      "prompt": "check for all possible problems under .github/",
      "promptId": "47487d13-prompt",
      "hasSeen": true,
      "logCount": 1,
      "logs": [
        {
          "id": "f3618761",
          "kind": "request",
          "type": "ChatMLSuccess",
          "name": "copilotLanguageModelWrapper",
          "metadata": {
            "requestType": "ChatCompletions",
            "model": "gpt-4o-mini",
            "maxPromptTokens": 12285,
            "maxResponseTokens": 4096,
            "location": 6,
            "startTime": "2026-02-12T22:14:15.514Z",
            "endTime": "2026-02-12T22:14:15.923Z",
            "duration": 409,
            "ourRequestId": "5788c95f-f757-4fa9-8ad2-b6502bfef707",
            "requestId": "5788c95f-f757-4fa9-8ad2-b6502bfef707",
            "serverRequestId": "5788c95f-f757-4fa9-8ad2-b6502bfef707",
            "timeToFirstToken": 329,
            "usage": {
              "completion_tokens": 9,
              "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "rejected_prediction_tokens": 0
              },
              "prompt_tokens": 1725,
              "prompt_tokens_details": {
                "cached_tokens": 1408
              },
              "total_tokens": 1734
            }
          },
          "requestMessages": {
            "messages": [
              {
                "role": 0,
                "content": [
                  {
                    "type": 1,
                    "text": "Follow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\nUse Markdown formatting in your answers.\nMake sure to include the programming language name at the start of the Markdown code blocks.\nAvoid wrapping the whole response in triple backticks.\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\nThe user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.\nThe active document is the source code the user is looking at right now.\nYou can only give one reply for each conversation turn.\n\n"
                  }
                ]
              },
              {
                "role": 1,
                "content": [
                  {
                    "type": 1,
                    "text": "Summarize the following content in a SINGLE sentence (under 10 words) using past tense. Follow these rules strictly:\n\n\t\t\tOUTPUT FORMAT:\n\t\t\t- MUST be a single sentence\n\t\t\t- MUST be under 10 words\n\t\t\t- No quotes, no trailing punctuation\n\n\t\t\tGENERAL:\n\t\t\t- The content may include tool invocations (file edits, reads, searches, terminal commands), reasoning headers, or raw thinking text\n\t\t\t- For reasoning headers or thinking text (no tool calls), summarize WHAT was considered/analyzed, NOT that thinking occurred\n\t\t\t- For thinking-only summaries, use phrases like: \"Considered...\", \"Planned...\", \"Analyzed...\", \"Reviewed...\"\n\n\t\t\tTOOL NAME FILTERING:\n\t\t\t- NEVER include tool names like \"Replace String in File\", \"Multi Replace String in File\", \"Create File\", \"Read File\", etc. in the output\n\t\t\t- If an action says \"Edited X and used Replace String in File\", output ONLY the action on X\n\t\t\t- Tool names describe HOW something was done, not WHAT was done - always omit them\n\n\t\t\tVOCABULARY - Use varied synonyms for natural-sounding summaries:\n\t\t\t- For edits: \"Updated\", \"Modified\", \"Changed\", \"Refactored\", \"Fixed\", \"Adjusted\"\n\t\t\t- For reads: \"Reviewed\", \"Examined\", \"Checked\", \"Inspected\", \"Analyzed\", \"Explored\"\n\t\t\t- For creates: \"Created\", \"Added\", \"Generated\"\n\t\t\t- For searches: \"Searched for\", \"Looked up\", \"Investigated\"\n\t\t\t- For terminal: \"Ran command\", \"Executed\"\n\t\t\t- For reasoning/thinking: \"Considered\", \"Planned\", \"Analyzed\", \"Reviewed\", \"Evaluated\"\n\t\t\t- Choose the synonym that best fits the context\n\n\t\t\tRULES FOR TOOL CALLS:\n\t\t\t1. If the SAME file was both edited AND read: Use a combined phrase like \"Reviewed and updated <filename>\"\n\t\t\t2. If exactly ONE file was edited: Start with an edit synonym + \"<filename>\" (include actual filename)\n\t\t\t3. If exactly ONE file was read: Start with a read synonym + \"<filename>\" (include actual filename)\n\t\t\t4. If MULTIPLE files were edited: Start with an edit synonym + \"X files\"\n\t\t\t5. If MULTIPLE files were read: Start with a read synonym + \"X files\"\n\t\t\t6. If BOTH edits AND reads occurred on DIFFERENT files: Combine them naturally\n\t\t\t7. For searches: Say \"searched for <term>\" or \"looked up <term>\" with the actual search term, NOT \"searched for files\"\n\t\t\t8. After the file info, you may add a brief summary of other actions if space permits\n\t\t\t9. NEVER say \"1 file\" - always use the actual filename when there's only one file\n\n\t\t\tRULES FOR REASONING HEADERS (no tool calls):\n\t\t\t1. If the input contains reasoning/analysis headers without actual tool invocations, summarize the main topic and what was considered\n\t\t\t2. Use past tense verbs that indicate thinking, not doing: \"Considered\", \"Planned\", \"Analyzed\", \"Evaluated\"\n\t\t\t3. Focus on WHAT was being thought about, not that thinking occurred\n\n\t\t\tRULES FOR RAW THINKING TEXT:\n\t\t\t1. Extract the main topic or question being considered from the text\n\t\t\t2. Identify any specific files, functions, or concepts mentioned\n\t\t\t3. Summarize as \"Analyzed <topic>\" or \"Considered <specific thing>\"\n\t\t\t4. If discussing code structure: \"Reviewed <component/architecture>\"\n\t\t\t5. If discussing a problem: \"Analyzed <problem description>\"\n\t\t\t6. If discussing implementation: \"Planned <feature/change>\"\n\n\t\t\tEXAMPLES WITH TOOLS:\n\t\t\t- \"Read HomePage.tsx, Edited HomePage.tsx\" â†’ \"Reviewed and updated HomePage.tsx\"\n\t\t\t- \"Edited HomePage.tsx\" â†’ \"Updated HomePage.tsx\"\n\t\t\t- \"Edited config.css and used Replace String in File\" â†’ \"Modified config.css\"\n\t\t\t- \"Edited App.tsx, used Multi Replace String in File\" â†’ \"Refactored App.tsx\"\n\t\t\t- \"Read config.json, Read package.json\" â†’ \"Reviewed 2 files\"\n\t\t\t- \"Edited App.tsx, Read utils.ts\" â†’ \"Updated App.tsx and checked utils.ts\"\n\t\t\t- \"Edited App.tsx, Read utils.ts, Read types.ts\" â†’ \"Updated App.tsx and reviewed 2 files\"\n\t\t\t- \"Edited index.ts, Edited styles.css, Ran terminal command\" â†’ \"Modified 2 files and ran command\"\n\t\t\t- \"Read README.md, Searched for AuthService\" â†’ \"Checked README.md and searched for AuthService\"\n\t\t\t- \"Searched for login, Searched for authentication\" â†’ \"Searched for login and authentication\"\n\t\t\t- \"Edited api.ts, Edited models.ts, Read schema.json\" â†’ \"Updated 2 files and reviewed schema.json\"\n\t\t\t- \"Edited Button.tsx, Edited Button.css, Edited index.ts\" â†’ \"Modified 3 files\"\n\t\t\t- \"Searched codebase for error handling\" â†’ \"Looked up error handling\"\n\n\t\t\tEXAMPLES WITH REASONING HEADERS (no tools):\n\t\t\t- \"Analyzing component architecture\" â†’ \"Considered component architecture\"\n\t\t\t- \"Planning refactor strategy\" â†’ \"Planned refactor strategy\"\n\t\t\t- \"Reviewing error handling approach, Considering edge cases\" â†’ \"Analyzed error handling approach\"\n\t\t\t- \"Understanding the codebase structure\" â†’ \"Reviewed codebase structure\"\n\t\t\t- \"Thinking about implementation options\" â†’ \"Considered implementation options\"\n\n\t\t\tEXAMPLES WITH RAW THINKING TEXT:\n\t\t\t- \"I need to understand how the authentication flow works in this app...\" â†’ \"Analyzed authentication flow\"\n\t\t\t- \"Let me think about how to refactor this component to be more maintainable...\" â†’ \"Planned component refactoring\"\n\t\t\t- \"The error seems to be coming from the database connection...\" â†’ \"Investigated database connection issue\"\n\t\t\t- \"Looking at the UserService class, I see it handles...\" â†’ \"Reviewed UserService implementation\"\n\n\t\t\tContent: Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/implementer.agent.md), Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/reviewer.agent.md), Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/agents/planner.agent.md), Reading skill [testing](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/testing/SKILL.md?vscodeLinkType%3Dskill), Reading skill [vscode-extensions](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/skills/vscode-extensions/SKILL.md?vscodeLinkType%3Dskill), Reading [](file:///Users/peterbru/Dropbox/Projects/copilot-lens/.github/copilot-instructions.md), Summarizing audit findings and next steps"
                  }
                ]
              }
            ]
          },
          "response": {
            "type": "success",
            "message": [
              "Reviewed 6 files and summarized audit findings"
            ]
          }
        }
      ]
    }
  ],
  "mcpServers": [
    {
      "type": "stdio",
      "label": "Bicep",
      "command": "/Users/peterbru/Library/Application Support/Code/User/globalStorage/ms-dotnettools.vscode-dotnet-runtime/.dotnet/10.0.3~x64/dotnet",
      "args": [
        "/Users/peterbru/.vscode/extensions/ms-azuretools.vscode-bicep-0.40.2/bicepMcpServer/Azure.Bicep.McpServer.dll"
      ]
    },
    {
      "type": "http",
      "label": "pylance mcp server",
      "uri": "http://[authority]/stream",
      "version": "2025.10.4"
    }
  ]
}